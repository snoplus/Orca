//--------------------------------------------------------
// OReGunModel
// Created by Mark  A. Howe on Wed Nov 28, 2007
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to g
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "OReGunModel.h"
#import "ORIP220Model.h"
#import "ORObjectProxy.h"

#pragma mark ***External Strings
NSString* OReGunModelStepTimeChanged = @"OReGunModelStepTimeChanged";
NSString* OReGunModelOvershootChanged = @"OReGunModelOvershootChanged";
NSString* OReGunModelStateStringChanged = @"OReGunModelStateStringChanged";
NSString* OReGunModelDecayTimeChanged = @"OReGunModelDecayTimeChanged";
NSString* OReGunModelDecayRateChanged = @"OReGunModelDecayRateChanged";
NSString* OReGunModelExcursionChanged = @"OReGunModelExcursionChanged";
NSString* OReGunModelViewTypeChanged = @"OReGunModelViewTypeChanged";
NSString* OReGunModelMillimetersPerVoltChanged = @"OReGunModelMillimetersPerVoltChanged";
NSString* OReGunModelChanYChanged		= @"OReGunModelChanYChanged";
NSString* OReGunModelChanXChanged		= @"OReGunModelChanXChanged";
NSString* OReGunModelEndEditing			= @"OReGunModelEndEditing";
NSString* OReGunModelMovingChanged		= @"OReGunModelMovingChanged";
NSString* OReGunModelAbsMotionChanged	= @"OReGunModelAbsMotionChanged";
NSString* OReGunModelCmdPositionChanged	= @"OReGunModelCmdPositionChanged";
NSString* OReGunModelPositionChanged	= @"OReGunModelPositionChanged";
NSString* OReGunX220NameChanged			= @"OReGunX220NameChanged";
NSString* OReGunY220NameChanged			= @"OReGunY220NameChanged";
NSString* OReGunX220ObjectChanged		= @"OReGunX220ObjectChanged";
NSString* OReGunY220ObjectChanged		= @"OReGunY220ObjectChanged";

NSString* OReGunLock = @"OReGunLock";

@interface OReGunModel (private)
- (void) resetTrackAndNotify;
- (void) step1;
- (void) step2;
- (void) step3;
- (void) step4;
- (void) step5;
- (void) step6;
- (void) step7;
@end

@implementation OReGunModel
- (id) init
{
	self = [super init];
	x220Object = [[ORObjectProxy alloc] initWithProxyName:@"ORIP220Model" slotNotification:ORVmeCardSlotChangedNotification];
	y220Object = [[ORObjectProxy alloc] initWithProxyName:@"ORIP220Model" slotNotification:ORVmeCardSlotChangedNotification];
	return self;
}

- (void) dealloc
{
    [stateString release];
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
	[x220Object release];
	[y220Object release];
	[[NSNotificationCenter defaultCenter] removeObserver:self];
	[super dealloc];
}

- (BOOL) solitaryObject
{
    return YES;
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"eGun.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"OReGunController"];
}

- (NSString*) helpURL
{
	return @"KATRIN/eGun_Controller.html";
}

- (ORObjectProxy*) x220Object
{
	return x220Object;
}

- (ORObjectProxy*) y220Object
{
	return y220Object;
}

#pragma mark ***Accessors

- (float) stepTime
{
    return stepTime;
}

- (void) setStepTime:(float)aStepTime
{
	if(aStepTime<.01)aStepTime = .01;
	else if(aStepTime>2)aStepTime = 2;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setStepTime:stepTime];
    
    stepTime = aStepTime;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelStepTimeChanged object:self];
}

- (float) overshoot
{
    return overshoot;
}

- (void) setOvershoot:(float)aOvershoot
{
	if(aOvershoot<0)aOvershoot=0;
	else if(aOvershoot>300)aOvershoot=300;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setOvershoot:overshoot];
    
    overshoot = aOvershoot;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelOvershootChanged object:self];
}

- (NSString*) stateString
{
    return stateString;
}

- (void) setStateString:(NSString*)aStateString
{
    [stateString autorelease];
    stateString = [aStateString copy];    
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelStateStringChanged object:self];
}

- (float) decayTime
{
    return decayTime;
}

- (void) setDecayTime:(float)aDecayTime
{
 	if(aDecayTime<=0.01)aDecayTime=0.01;
	else if(aDecayTime>1)aDecayTime = 1;
    [[[self undoManager] prepareWithInvocationTarget:self] setDecayTime:decayTime];
    
    decayTime = aDecayTime;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelDecayTimeChanged object:self];
}

- (float) decayRate
{
    return decayRate;
}

- (void) setDecayRate:(float)aDecayRate
{
 	if(aDecayRate<=1)aDecayRate=1;
	else if(aDecayRate>99)aDecayRate = 99;
	[[[self undoManager] prepareWithInvocationTarget:self] setDecayRate:decayRate];
    
    decayRate = aDecayRate;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelDecayRateChanged object:self];
}

- (float) excursion
{
    return excursion;
}

- (void) setExcursion:(float)aExcursion
{
	if(aExcursion<=1)aExcursion=1;
	else if(aExcursion>200)aExcursion = 200;
    [[[self undoManager] prepareWithInvocationTarget:self] setExcursion:excursion];
    
    excursion = aExcursion;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelExcursionChanged object:self];
}

- (int) viewType
{
    return viewType;
}

- (void) setViewType:(int)aViewType
{
    [[[self undoManager] prepareWithInvocationTarget:self] setViewType:viewType];
    
    viewType = aViewType;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelViewTypeChanged object:self];
}

- (float) millimetersPerVolt
{
    return millimetersPerVolt;
}

- (void) setMillimetersPerVolt:(float)aMillimetersPerVolt
{
	if(aMillimetersPerVolt==0)aMillimetersPerVolt = 0.001;
	else if(aMillimetersPerVolt<.001)aMillimetersPerVolt = 0.001;
	else if(aMillimetersPerVolt>50)aMillimetersPerVolt = 50;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setMillimetersPerVolt:millimetersPerVolt];
    
    millimetersPerVolt = aMillimetersPerVolt;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelMillimetersPerVoltChanged object:self];
}

- (unsigned short) chanY
{
    return chanY;
}

- (void) setChanY:(unsigned short)aChanY
{
    [[[self undoManager] prepareWithInvocationTarget:self] setChanY:chanY];
	if(aChanY>15)aChanY=15;
    chanY = aChanY;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelChanYChanged object:self];
}

- (unsigned short) chanX
{
    return chanX;
}

- (void) setChanX:(unsigned short)aChanX
{
    [[[self undoManager] prepareWithInvocationTarget:self] setChanX:chanX];
    
	if(chanX>15)chanX=15;
    chanX = aChanX;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelChanXChanged object:self];
}

- (BOOL) moving
{
    return moving;
}

- (void) setMoving:(BOOL)aMoving
{
    if(moving!=aMoving){
        moving = aMoving;
		if(!moving){
			[self performSelector:@selector(resetTrackAndNotify) withObject:nil afterDelay:.3];
			[self setStateString:@""];
			
		}
        [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelMovingChanged object:self];
    }
}

- (unsigned)currentTrackIndex
{
    return currentTrackIndex;
}

- (unsigned)validTrackCount
{
    return validTrackCount;
}

- (NSPoint) track:(unsigned)i
{
    if(i<kNumTrackPoints)return track[i];
    else return NSZeroPoint;
}


- (BOOL) absMotion
{
    return absMotion;
}

- (void) setAbsMotion:(BOOL)aAbsMotion
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAbsMotion:absMotion];
    
    absMotion = aAbsMotion;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelAbsMotionChanged object:self];
}

- (NSPoint) cmdPosition
{
    return cmdPosition;
}

- (void) setCmdPosition:(NSPoint)aCmdPosition
{
    [[[self undoManager] prepareWithInvocationTarget:self] setCmdPosition:cmdPosition];
    
    cmdPosition = aCmdPosition;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelCmdPositionChanged object:self];
}


- (NSPoint) xyVoltage
{
	NSPoint xyVoltage;
	@try {
		float x = 0;
		float y = 0;
		if([x220Object hwObject])x = [x220Object outputVoltage:chanX];
		if([y220Object hwObject])y = [y220Object outputVoltage:chanY];
		xyVoltage = NSMakePoint(x, y);
	}
	@catch(NSException* localException) {
		xyVoltage = NSZeroPoint;
	}
    return xyVoltage;
}

- (void) setXyVoltage:(NSPoint)aPoint
{
	@try {
		[x220Object setOutputVoltage:chanX withValue:aPoint.x - 0.01*aPoint.y];
		[y220Object setOutputVoltage:chanY withValue:aPoint.y - 0.01*aPoint.x];
	}
	@catch(NSException* localException) {
	}
}

- (void) updateTrack
{				
	track[currentTrackIndex] = [self xyVoltage];
	currentTrackIndex  = currentTrackIndex++;
	if(currentTrackIndex>=kNumTrackPoints)currentTrackIndex = 0;
	validTrackCount++;
	if(validTrackCount>kNumTrackPoints)validTrackCount= kNumTrackPoints;
	
	[[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelPositionChanged object:self];
}

#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setStepTime:[decoder decodeFloatForKey:@"OReGunModelStepTime"]];
	[self setOvershoot:[decoder decodeFloatForKey:@"OReGunModelOvershoot"]];
	[self setDecayTime:[decoder decodeFloatForKey:@"OReGunModelDecayTime"]];
	[self setDecayRate:[decoder decodeFloatForKey:@"OReGunModelDecayRate"]];
	[self setExcursion:[decoder decodeFloatForKey:@"OReGunModelExcursion"]];
	[self setViewType:[decoder decodeIntForKey:@"OReGunModelViewType"]];
	[self setMillimetersPerVolt:[decoder decodeFloatForKey:@"OReGunModelMillimetersPerVolt"]];
	[self setChanY:[decoder decodeIntForKey:@"OReGunModelChanY"]];
	[self setChanX:[decoder decodeIntForKey:@"OReGunModelChanX"]];
	[self setAbsMotion:[decoder decodeBoolForKey:    @"OReGunModelAbsMotion"]];
	[self setCmdPosition:[decoder decodePointForKey: @"OReGunModelCmdPosition"]];
	x220Object = [[decoder decodeObjectForKey: @"x220Object"] retain];
	y220Object = [[decoder decodeObjectForKey: @"y220Object"] retain];
	[[self undoManager] enableUndoRegistration];
	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeFloat:stepTime forKey:@"OReGunModelStepTime"];
    [encoder encodeFloat:overshoot forKey:@"OReGunModelOvershoot"];
    [encoder encodeFloat:decayTime forKey:@"OReGunModelDecayTime"];
    [encoder encodeFloat:decayRate forKey:@"OReGunModelDecayRate"];
    [encoder encodeFloat:excursion forKey:@"OReGunModelExcursion"];
    [encoder encodeInt:viewType forKey:@"OReGunModelViewType"];
    [encoder encodeFloat:millimetersPerVolt forKey:@"OReGunModelMillimetersPerVolt"];
    [encoder encodeInt:chanY forKey:@"OReGunModelChanY"];
    [encoder encodeInt:chanX forKey:@"OReGunModelChanX"];
    [encoder encodeObject:x220Object forKey:@"x220Object"];
    [encoder encodeObject:y220Object forKey:@"y220Object"];
	[encoder encodeBool:absMotion forKey:  @"OReGunModelAbsMotion"];
    [encoder encodePoint:cmdPosition forKey: @"OReGunModelCmdPosition"];
}

#pragma mark ***eGun Commands
- (void) getPosition
{
	@try {
		[x220Object readBoard];
		if([x220Object hwObject] != [y220Object hwObject]){
			[y220Object readBoard];
		}
	}
	@catch(NSException* localException) {
	}
	
}

- (void) stopMotion
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[self setMoving:NO];
}

- (void) go
{
	[self resetTrack];
	if(absMotion) goalPosition = cmdPosition;
	else {
		NSPoint xyVolts = [self xyVoltage];
		goalPosition = NSMakePoint(xyVolts.x+cmdPosition.x, xyVolts.y+cmdPosition.x);
	}
	//Start move past to 0,0
	[self setStateString:[NSString stringWithFormat:@"Moving %.0f%% Past 0,0",overshoot]];
	NSPoint currentPt	= [self xyVoltage];
	NSPoint delta 		= NSMakePoint((0 - currentPt.x)*overshoot/100.,(0 - currentPt.y)*overshoot/100.);
	NSPoint newPt		= NSMakePoint(0 + delta.x,0 + delta.y);
	
	[self setXyVoltage:newPt];
	[self loadBoard];
	[self updateTrack];
	[self performSelector:@selector(step1) withObject:nil afterDelay:stepTime];
}




- (void) resetTrack
{
    currentTrackIndex = 0;
    validTrackCount   = 0;
}

- (void) degauss
{
 	[self setMoving:YES];
	degaussPosition = [self xyVoltage];
	[self updateTrack];
	firstPoint = YES;
	
	[self performSelector:@selector(processDegauss) withObject:nil afterDelay:decayTime];		
}

- (void) processDegauss
{
	//Note that all values are stored as raw values. Any conversion needed is done only for the display code.
	[[self undoManager] disableUndoRegistration];
	
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(processDegauss) object:nil];
	
	if(firstPoint){
		NSPoint newPt		= NSMakePoint(degaussPosition.x + [self excursion]/millimetersPerVolt,degaussPosition.y + [self excursion]/millimetersPerVolt);
		[self setXyVoltage:newPt];
		firstPoint = NO;
		[self performSelector:@selector(processDegauss) withObject:nil afterDelay:[self decayTime]];
	}
	else {
		NSPoint currentPt	= [self xyVoltage];
		NSPoint delta 		= NSMakePoint((degaussPosition.x - currentPt.x)*[self decayRate]/100.,(degaussPosition.y - currentPt.y)*[self decayRate]/100.);
		NSPoint newPt		= NSMakePoint(degaussPosition.x + delta.x,degaussPosition.y + delta.y);
		
		if(fabs(delta.x*millimetersPerVolt) > .5){
			[self setXyVoltage:newPt];
			[self performSelector:@selector(processDegauss) withObject:nil afterDelay:[self decayTime]];
		}
		else {
			[self setXyVoltage:degaussPosition];
			[self setMoving:NO];		
		}
		
	}
	
	[self updateTrack];
	[self loadBoard];
	
	[[self undoManager] enableUndoRegistration];
	
}

- (void) loadBoard
{
	@try {
		[x220Object initBoard];
		if([x220Object hwObject] != [y220Object hwObject]){
			[y220Object initBoard];
		}
	}
	@catch(NSException* localException) {
	}
	
}
@end

@implementation OReGunModel (private)
- (void) resetTrackAndNotify
{
	[self resetTrack];
	track[currentTrackIndex] = [self xyVoltage];
	currentTrackIndex  = currentTrackIndex++;
	validTrackCount++;
	[[NSNotificationCenter defaultCenter] postNotificationName:OReGunModelPositionChanged object:self];
}

- (void) step1
{
	//Step 1 move to -100,-100
 	[self setMoving:YES];
	[self setStateString:@"Moving To -100,-100"];
	[self setXyVoltage:NSMakePoint(-100./millimetersPerVolt,-100./millimetersPerVolt)];
	[self loadBoard];
	[self updateTrack];
	[self performSelector:@selector(step2) withObject:nil afterDelay:stepTime];
	
}

- (void) step2
{
	//Step 2 move to 100,100
	[self setStateString:@"Moving To 100,100"];
	[self setXyVoltage:NSMakePoint(100./millimetersPerVolt,100./millimetersPerVolt)];
	[self loadBoard];
	[self updateTrack];
	[self performSelector:@selector(step3) withObject:nil afterDelay:stepTime];
}


- (void) step3
{
	//Step 3 move to 0,0
	[self setStateString:@"Moving To 0,0"];
	[self setXyVoltage:NSMakePoint(0,0)];
	[self loadBoard];
	[self updateTrack];
	[self performSelector:@selector(step4) withObject:nil afterDelay:stepTime];
}


- (void) step4
{
	[self setStateString:@"Degaussing"];
	[self degauss];
	[self performSelector:@selector(step5) withObject:nil afterDelay:stepTime];
}

- (void) step5
{
	//wait for degauss to finish
	if(moving){
		[self setStateString:@"Wait for Degauss"];
		[self performSelector:@selector(step5) withObject:nil afterDelay:stepTime];
	}
	else {
		[self setMoving:YES];
		[self setXyVoltage:goalPosition];
		[self loadBoard];
		[self updateTrack];
		[self performSelector:@selector(step6) withObject:nil afterDelay:stepTime];
	}
}

- (void) step6
{
	[self setStateString:@"Degaussing"];
	//NSPoint currentPosition = [self xyVoltage];
	[self degauss];
	[self performSelector:@selector(step7) withObject:nil afterDelay:stepTime];
}

- (void) step7
{
	//wait for degauss to finish
	if(moving){
		[self setStateString:@"Wait for Degauss"];
		[self performSelector:@selector(step7) withObject:nil afterDelay:stepTime];
	}
	else {
		[self setMoving:NO];
		[self setStateString:@""];
		//NSPoint currentPosition = [self xyVoltage];
		
		[self setXyVoltage:goalPosition];
		[self loadBoard];
		[self updateTrack];
	}
}

@end
