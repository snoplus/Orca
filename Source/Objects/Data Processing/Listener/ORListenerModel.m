//--------------------------------------------------------
// ORListenerModel
// Created by Mark  A. Howe on Mon Apr 11 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORListenerModel.h"
#import "NetSocket.h"
#import "ORDataTaker.h"
#import "ORDecoder.h"
#import "ORDataTaker.h"
#import "ORDataTypeAssigner.h"
#import "ORDataProcessing.h"

#pragma mark ***External Strings
NSString* ORListenerConnectAtStartChanged	= @"ORListenerConnectAtStartChanged";
NSString* ORListenerAutoReconnectChanged	= @"ORListenerAutoReconnectChanged";
NSString* ORListenerQueueCountChanged		= @"ORListenerQueueCountChanged";
NSString* ORListenerRemotePortChanged		= @"ORListenerRemotePortChanged";
NSString* ORListenerRemoteHostChanged		= @"ORListenerRemoteHostChanged";
NSString* ORListenerIsConnectedChanged		= @"ORListenerIsConnectedChanged";
NSString* ORListenerByteCountChanged		= @"ORListenerByteCountChanged";
NSString* ORListenerLock                    = @"ORListenerLock";

static NSString* ORListenerConnector = @"ORListenerConnector";

@interface ORListenerModel (processThread)
- (void) processDataFromQueue;
- (void) processDataBuffer;
- (void) startProcessing;
- (void) stopProcessing;
- (void) reConnect;
@end

@interface ORListenerModel (private)
- (void) setCurrentDecoder:(ORDecoder*)aDecoder;
- (void) loadRunInfoFromRunRecord:(uint32_t*)p;
- (void) loadRunInfoFromHeader;
- (void) processRunRecord:(uint32_t*)p;
- (void) sendDataArray:(NSArray*)dataArray decoder:(ORDecoder*)aDecoder;
- (void) sendByteUpdateDelayed;
- (void) sendByteUpdate;

@end

@implementation ORListenerModel
- (id) init
{
	self = [super init];
	return self;
}

- (void) dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[remoteHost release];
    [socket setDelegate:nil];
	[socket release];
	[dataArray release];
	[currentDecoder release];
	[dataToProcess release];
	[runInfo release];
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"Listener"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORListenerController"];
}

- (NSString*) helpURL
{
	return @"Data_Chain/Listener.html";
}

- (void) makeConnectors
{
    ORConnector* aConnector = [[ORConnector alloc] initAt:NSMakePoint([self frame].size.width-kConnectorSize,[self frame].size.height/2 - kConnectorSize/2) withGuardian:self withObjectLink:self];
    [[self connectors] setObject:aConnector forKey:ORListenerConnector];
	[aConnector setIoType:kOutputConnector];
    [aConnector release];
    
}

#pragma mark ¥¥¥Notifications
- (void) registerNotificationObservers
{
    NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];
    
    [notifyCenter addObserver : self
                     selector : @selector(connectionChanged:)
                         name : ORConnectionChanged
                       object : nil];
    
    [notifyCenter addObserver : self
                     selector : @selector(documentLoaded:)
                         name : ORDocumentLoadedNotification
                       object : nil];
    
    
}

- (void) documentLoaded:(NSNotification*)aNotification
{
    if([self objectConnectedTo:ORListenerConnector] && connectAtStart){
        docLoaded = YES;
        [self connectSocket:YES];
    }
}

- (void) connectionChanged:(NSNotification*)aNotification
{
    if([aNotification object] == self){
        if([self objectConnectedTo:ORListenerConnector]){
            if(docLoaded){
                [self connectSocket:YES];
            }
        }
        else {
            [self connectSocket:NO];
        }
    }
}

#pragma mark ***Accessors

- (BOOL) connectAtStart
{
	return connectAtStart;
}

- (void) setConnectAtStart:(BOOL)aConnectAtStart
{
	[[[self undoManager] prepareWithInvocationTarget:self] setConnectAtStart:connectAtStart];
    
	connectAtStart = aConnectAtStart;
    
	[[NSNotificationCenter defaultCenter]
	 postNotificationName:ORListenerConnectAtStartChanged
	 object:self];
}
- (BOOL) autoReconnect
{
	return autoReconnect;
}
- (void) setAutoReconnect:(BOOL)aAutoReconnect
{
	[[[self undoManager] prepareWithInvocationTarget:self] setAutoReconnect:autoReconnect];
    
	autoReconnect = aAutoReconnect;
    
    if(!autoReconnect)[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(reConnect) object:nil];

    
	[[NSNotificationCenter defaultCenter]
	 postNotificationName:ORListenerAutoReconnectChanged
	 object:self];
}

- (NetSocket*) socket
{
	return socket;
}
- (void) setSocket:(NetSocket*)aSocket
{
	[aSocket retain];
	[socket release];
	socket = aSocket;
    [socket setDelegate:self];
}

- (unsigned short) remotePort
{
	return remotePort;
}
- (void) setRemotePort:(unsigned short)aNewRemotePort
{
	[[[self undoManager] prepareWithInvocationTarget:self] setRemotePort:remotePort];
    
	remotePort = aNewRemotePort;
    
	[[NSNotificationCenter defaultCenter] 
	 postNotificationName:ORListenerRemotePortChanged 
	 object: self];
}

- (NSString*) remoteHost
{
	return remoteHost;
}
- (void) setRemoteHost:(NSString*)aNewRemoteHost
{
    if(!aNewRemoteHost)aNewRemoteHost = @"";
    
    NSString* thisHostAdress    = [[NSHost currentHost] address];
    NSString* remoteHostAddress = [[NSHost hostWithName:aNewRemoteHost] address];
    
    if([thisHostAdress isEqualToString:remoteHostAddress]){
        aNewRemoteHost = @"";   
        NSLog(@"Sorry, you can not connect a Listener to the local host.\n"); 
        NSLog(@"The remote host must be a different computer.\n"); 
    }
    
	[[[self undoManager] prepareWithInvocationTarget:self] setRemoteHost:remoteHost];
    
	[remoteHost autorelease];
	remoteHost = [aNewRemoteHost copy];
    
	[[NSNotificationCenter defaultCenter] 
	 postNotificationName:ORListenerRemoteHostChanged 
	 object: self ];
}

- (BOOL) isConnected
{
	return isConnected;
}
- (void) setIsConnected:(BOOL)aNewIsConnected
{
	isConnected = aNewIsConnected;
    
	[[NSNotificationCenter defaultCenter] 
	 postNotificationName:ORListenerIsConnectedChanged 
	 object: self ];
}

- (uint32_t) byteCount
{
	return byteCount;
}
- (void) setByteCount:(uint32_t)aNewByteCount
{
	byteCount = aNewByteCount;
	if(!scheduledForUpdate){
		byteCount = 0;
		[self performSelectorOnMainThread:@selector(sendByteUpdateDelayed) withObject:nil waitUntilDone:NO];
		scheduledForUpdate = YES;
	}
}

- (void) clearByteCount
{
    [self setByteCount:0];
}

- (void) incByteCount:(uint32_t)anAmount
{
    uint32_t newAmount = byteCount + anAmount;
	[self setByteCount:newAmount];
}

- (void) connectSocket:(BOOL)state
{
    if(state){
		[dataArray release];
		dataArray = [[NSMutableArray arrayWithCapacity:1024*1024] retain];
		firstTime = YES;
        [self setSocket:[NetSocket netsocketConnectedToHost:remoteHost port:remotePort]];
		[self setCurrentDecoder:[[[ORDecoder alloc] init] autorelease]];
    }
    else {
        [socket close];
        [self stopProcessing];
        [self setIsConnected:[socket isConnected]];
    }
}

#pragma mark ***Delegate Methods
- (void) netsocketConnected:(NetSocket*)inNetSocket
{
    if(inNetSocket == socket){
        [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(reConnect) object:nil];
        [self startProcessing];
        [self setIsConnected:[socket isConnected]];
        [self setIsConnected:YES];
    }
}

- (void) netsocketDisconnected:(NetSocket*)inNetSocket
{
    if(inNetSocket == socket){
        [self stopProcessing];
        [self setIsConnected:[socket isConnected]];
        if(autoReconnect)[self performSelector:@selector(reConnect) withObject:nil afterDelay:10];
        [self setIsConnected:NO];
    }
}

- (void) netsocket:(NetSocket*)inNetSocket dataAvailable:(NSUInteger)inAmount
{
    if(inNetSocket == socket){
        if(threadRunning){
            @synchronized(self){
                if(!dataToProcess)dataToProcess = [[NSMutableData alloc] initWithCapacity:50000];
                NSData* theData = [socket readData];
                [dataToProcess appendData:theData];
                [self incByteCount:(uint32_t)[theData length]];
            }
        }
    }
}

#pragma mark ***Archival

- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
    
	[self setRemoteHost:[decoder decodeObjectForKey:@"ORListenerRemoteHost"]];
    [self setConnectAtStart:[decoder decodeBoolForKey:@"ConnectAtStart"]];
    [self setAutoReconnect:[decoder decodeBoolForKey:@"AutoReconnect"]];
	[self setRemotePort:[decoder decodeIntegerForKey:@"ORListenerRemotePort"]];
    
	[[self undoManager] enableUndoRegistration];
    
    if(remotePort==0)remotePort = 44666;
	[self registerNotificationObservers];
    
	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
	[encoder encodeObject:remoteHost forKey:@"ORListenerRemoteHost"];
    [encoder encodeBool:connectAtStart forKey:@"ConnectAtStart"];
    [encoder encodeBool:autoReconnect forKey:@"AutoReconnect"];
	[encoder encodeInteger:remotePort forKey:@"ORListenerRemotePort"];
}

- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{
	NSMutableDictionary* objDictionary = [NSMutableDictionary dictionary];
    if(remoteHost)[objDictionary setObject:remoteHost forKey:@"RemoteHost"];
    [objDictionary setObject:[NSNumber numberWithInt:connectAtStart] forKey:@"ConnectAtStart"];
    [objDictionary setObject:[NSNumber numberWithInt:autoReconnect] forKey:@"AutoReconnect"];
    [objDictionary setObject:[NSNumber numberWithInt:remotePort] forKey:@"RemotePort"];
    [dictionary setObject:objDictionary forKey:@"Listener"];
    
    return objDictionary;
}


@end

@implementation ORListenerModel (processThread)
//-----------------------------------------------------------
//processDataFromQueue runs out of the processing thread
//-----------------------------------------------------------
- (void) processDataFromQueue
{
    
    if(![socket isConnected])return;
	
	BOOL flushMessagePrintedOnce = NO;
    threadRunning                = YES;
    do {
        NSAutoreleasePool *pool = [[NSAutoreleasePool allocWithZone:nil] init];
        @synchronized(self){

            if(timeToQuit){
                uint32_t numBytesLeft = (uint32_t)[dataToProcess length];
                if(!flushMessagePrintedOnce){
                    if(numBytesLeft) NSLog(@"flushing %d bytes from listening queue\n",numBytesLeft);
                    flushMessagePrintedOnce = YES;						
                }
                if(numBytesLeft == 0)break;
            }
            else [self processDataBuffer];

        }
        [NSThread sleepForTimeInterval:.01];
        [pool release];
    } while(!timeToQuit);
    
    threadRunning = NO;
}

- (void) processDataBuffer
{
	uint32_t* p                = (uint32_t*)[dataToProcess bytes];
	uint32_t* endPtr           = p + [dataToProcess length]/sizeof(int32_t);
	uint32_t bytesProcessed	= 0;
    uint32_t longsInBuffer     = (uint32_t)[dataToProcess length]/sizeof(int32_t);
	while(p<endPtr){
		uint32_t firstWord		= *p;
		//the first time is a special case. We have to have a header as the first record or we can not continue
		if(firstTime){
			runEnded = NO;
			if(longsInBuffer >= 1){
				if([currentDecoder legalData:dataToProcess]){
					if(needToSwap)firstWord		= CFSwapInt32(*p);
					uint32_t recordLength	= ExtractLength(firstWord);
					if(longsInBuffer >= recordLength){
						//OK we have enough to load the header and make a decoder
						[currentDecoder loadHeader:(uint32_t*)p];
						needToSwap = [currentDecoder needToSwap];
						[self loadRunInfoFromHeader];
                        runDataID = (uint32_t)[[currentDecoder headerObject:@"dataDescription",@"ORRunModel",@"Run",@"dataId",nil] longValue];
						id nextObject = [self objectConnectedTo:ORListenerConnector];
						[nextObject runTaskStarted:runInfo];
                        [dataArray addObject:[NSData dataWithBytes:p length:recordLength*sizeof(int32_t)]];

						firstTime = NO;
                        p += recordLength;
                        bytesProcessed = recordLength*sizeof(int32_t);
                        longsInBuffer -= recordLength;

					}
                    else break;
				}
				else break;
			}
		}
		else {
			if(needToSwap)firstWord		= CFSwapInt32(*p);
			uint32_t dataId		= ExtractDataId(firstWord);
			uint32_t recordLength	= ExtractLength(firstWord);
			
			if(longsInBuffer >= recordLength){
				if(needToSwap){
					[currentDecoder byteSwapData:(uint32_t*)p forKey:[NSNumber numberWithLong:dataId]];
				}
				if(dataId == 0x0){
					[currentDecoder loadHeader:(uint32_t*)p];
					needToSwap = [currentDecoder needToSwap];
					runDataID = (uint32_t)[[currentDecoder headerObject:@"dataDescription",@"ORRunModel",@"Run",@"dataId",nil] longValue];
				}
				else if(dataId == runDataID)[self processRunRecord:(uint32_t*)p];
				
				[dataArray addObject:[NSData dataWithBytes:p length:recordLength*sizeof(int32_t)]];
				
				p               += recordLength;
				bytesProcessed  += recordLength * sizeof(int32_t);
				longsInBuffer   -= recordLength;
				if(runEnded)break;
			}
            else if(timeToQuit){
                [dataToProcess release];
                dataToProcess = nil;
            }
			else break;
		}

	}
    if(bytesProcessed){
        [dataToProcess replaceBytesInRange:NSMakeRange( 0, MIN(bytesProcessed,[dataToProcess length]) ) withBytes:NULL length:0];
    }
	if([dataArray count]){
		[self sendDataArray:dataArray decoder:currentDecoder];
		[dataArray removeAllObjects];
        if(runEnded){
            id nextObject = [self objectConnectedTo:ORListenerConnector];
            [nextObject closeOutRun:runInfo];
            [self setByteCount:0];
        }
	}
	
}

- (void) startProcessing
{
    if(!threadRunning && [socket isConnected]){
        timeToQuit  = NO;
        [self setByteCount:0];
        [NSThread detachNewThreadSelector:@selector(processDataFromQueue) toTarget:self withObject:nil];
    }        
}

- (void) stopProcessing
{
    if(threadRunning){
        timeToQuit = YES;

        //....wait for processing to finish.....
        //wait for the processing thread to exit.
        NSTimeInterval t0 = [NSDate timeIntervalSinceReferenceDate];
        while(threadRunning){
            [NSThread sleepUntilDate:[[NSDate date] dateByAddingTimeInterval:.01]];
            if([NSDate timeIntervalSinceReferenceDate]-t0 > 10){
                threadRunning = NO;
                break;
            }
        }
	}
	[dataToProcess release];
	dataToProcess = nil;
	[self setByteCount:0];
	[socket readData]; //flush the socket.
}

- (void) reConnect
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(reConnect) object:nil];
    [self connectSocket:YES];
    if(autoReconnect)[self performSelector:@selector(reConnect) withObject:nil afterDelay:10];
}

@end

@implementation ORListenerModel (private)

- (void) sendByteUpdateDelayed
{
	[self performSelector:@selector(sendByteUpdate) withObject:nil afterDelay:1.0];
}

- (void) sendByteUpdate
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(sendByteUpdate) object:nil];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORListenerByteCountChanged object: self ];
	scheduledForUpdate = NO;
}
- (void) setCurrentDecoder:(ORDecoder*)aDecoder
{
	[aDecoder retain];
	[currentDecoder release];
	currentDecoder = aDecoder;
}

- (void) loadRunInfoFromRunRecord:(uint32_t*)p
{
	//pack up some info about the run.
	[runInfo release];
	runInfo = [[NSMutableDictionary dictionaryWithObjectsAndKeys:
				[currentDecoder fileHeader], kHeader,
				[NSNumber numberWithLong:p[2]],kRunNumber,
				[NSNumber numberWithLong:p[1]>>16],kSubRunNumber,
				[NSNumber numberWithLong:kNormalRun],  kRunMode,
				nil] retain];
	
}

- (void) loadRunInfoFromHeader
{
	//pack up some info about the run.
	[runInfo release];
	NSNumber* runNumber    = [currentDecoder headerObject:@"ObjectInfo",@"DataChain",@"0",@"Run Control",@"RunNumber",nil];
	NSNumber* subRunNumber = [currentDecoder headerObject:@"ObjectInfo",@"DataChain",@"0",@"Run Control",@"SubRunNumber",nil];

	runInfo = [[NSMutableDictionary dictionaryWithObjectsAndKeys:
				[currentDecoder fileHeader], kHeader,
				runNumber,kRunNumber,
				subRunNumber,kSubRunNumber,
				[NSNumber numberWithLong:kNormalRun],  kRunMode,
				nil] retain];
	
}


- (void) processRunRecord:(uint32_t*)p
{
	uint32_t theDataWord = *(p+1);
	id nextObject = [self objectConnectedTo:ORListenerConnector];
	
	if((theDataWord & 0x8)){
		//heart beat
	}
	else {
		if(theDataWord & 0x1){
			[self loadRunInfoFromRunRecord:p];
			[nextObject runTaskStarted:runInfo];
			[nextObject setInvolvedInCurrentRun:YES];
		}
		else if(theDataWord & 0x10){
			//send prepare sub run
		}
		else if(theDataWord & 0x20){
			[nextObject subRunTaskStarted:runInfo];
		}
		else {
			[nextObject runTaskStopped:runInfo];
			runEnded = YES;
			firstTime = YES;
		}
	}
}

- (void) sendDataArray:(NSArray*)aDataArray decoder:(ORDecoder*)aDecoder
{
	if([aDataArray count]){
		id nextObject = [self objectConnectedTo:ORListenerConnector];
		[nextObject processData:aDataArray decoder:aDecoder];
	}
}

@end
