//--------------------------------------------------------
// ORCMC203Model
// Created by Mark  A. Howe on Tue Aug 02 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORCMC203Model.h"
#import "ORHWWizParam.h"
#import "ORHWWizSelection.h"
#import "OHexFormatter.h"
#import "ORDataTypeAssigner.h"
#import "ORCamacCrateModel.h"
#import "ORCamacControllerCard.h"
#import "ORRateGroup.h"
#import "ORReadOutList.h"

#pragma mark ***External Strings
NSString* ORCMC203ModelHistoMaskChanged = @"ORCMC203ModelHistoMaskChanged";
NSString* ORCMC203ModelOperationModeChanged		= @"ORCMC203ModelOperationModeChanged";
NSString* ORCMC203ModelAdcBitsChanged			= @"ORCMC203ModelAdcBitsChanged";
NSString* ORCMC203ModelHistogramModeChanged		= @"ORCMC203ModelHistogramModeChanged";
NSString* ORCMC203ModelWordSizeChanged			= @"ORCMC203ModelWordSizeChanged";
NSString* ORCMC203ModelHistogramLengthChanged	= @"ORCMC203ModelHistogramLengthChanged";
NSString* ORCMC203ModelHistogramStartChanged	= @"ORCMC203ModelHistogramStartChanged";
NSString* ORCMC203RateGroupChangedNotification  = @"ORCMC203RateGroupChangedNotification";
NSString* ORCMC203HistoDataChangedNotification  = @"ORCMC203HistoDataChangedNotification";

NSString* ORCMC203SettingsLock					= @"ORCMC203SettingsLock";

@implementation ORCMC203Model
- (id) init
{
	self = [super init];
	[self setFifoRateGroup:[[[ORRateGroup alloc] initGroup:1 groupTag:0] autorelease]];
	[fifoRateGroup setIntegrationTime:5];
	ORReadOutList* readList = [[ORReadOutList alloc] initWithIdentifier:@"FERA Objects"];
	[readList setAcceptedProtocol:@"ORFeraReadout"];
	[readList addAcceptedObjectName:@"ORAD413AModel"];
	[self setReadOutGroup:readList];
	[readList release];
	return self;
}

- (void) dealloc
{
    [fifoRateGroup quit];
    [fifoRateGroup release];
	[histogramData release];
	[readOutGroup release];
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"CMC203Card"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORCMC203Controller"];
}

#pragma mark ***Accessors

- (uint32_t) histoMask
{
    return histoMask;
}

- (void) setHistoMask:(uint32_t)aHistoMask
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHistoMask:histoMask];
    
    histoMask = aHistoMask;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelHistoMaskChanged object:self];
}


- (ORRateGroup*) fifoRateGroup
{
	return fifoRateGroup;
}

- (void) setFifoRateGroup:(ORRateGroup*)newFifoRateGroup
{
	[newFifoRateGroup retain];
	[fifoRateGroup release];
	fifoRateGroup = newFifoRateGroup;
	

    [[NSNotificationCenter defaultCenter] 
		postNotificationName:ORCMC203RateGroupChangedNotification
					  object:self];    
}

- (void) setIntegrationTime:(double)newIntegrationTime
{
	//we this here so we have undo/redo on the rate object.
    [[[self undoManager] prepareWithInvocationTarget:self] setIntegrationTime:[fifoRateGroup integrationTime]];
	[fifoRateGroup setIntegrationTime:newIntegrationTime];
}

- (ORReadOutList*) readOutGroup
{
	return readOutGroup;
}

- (void) setReadOutGroup:(ORReadOutList*)newReadOutGroup
{
	[readOutGroup autorelease];
	readOutGroup=[newReadOutGroup retain];
}

- (NSMutableArray*) children 
{
	//method exists to give common interface across all objects for display in lists
	return [NSMutableArray arrayWithObject:readOutGroup];
}

- (int) operationMode
{
    return operationMode;
}

- (void) setOperationMode:(int)aMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setOperationMode:operationMode];
    operationMode = aMode;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelOperationModeChanged object:self];
}

- (int) adcBits
{
    return adcBits;
}

- (void) setAdcBits:(int)aAdcBits
{
	if(aAdcBits<8)aAdcBits = 8;
	if(aAdcBits>=16)aAdcBits=16;
    [[[self undoManager] prepareWithInvocationTarget:self] setAdcBits:adcBits];
    adcBits = aAdcBits;
	if(histogramData){
		[histogramData release];
		histogramData = nil;
	}
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelAdcBitsChanged object:self];
}

- (int) histogramMode
{
    return histogramMode;
}

- (void) setHistogramMode:(int)aHistogramMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHistogramMode:histogramMode];
    histogramMode = aHistogramMode;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelHistogramModeChanged object:self];
}

- (int) wordSize
{
    return wordSize;
}

- (void) setWordSize:(int)aWordSize
{
    [[[self undoManager] prepareWithInvocationTarget:self] setWordSize:wordSize];
    wordSize = aWordSize;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelWordSizeChanged object:self];
}

- (int32_t) histogramLength
{
    return histogramLength;
}

- (void) setHistogramLength:(int32_t)aHistogramLength
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHistogramLength:histogramLength];
    histogramLength = aHistogramLength;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelHistogramLengthChanged object:self];
}

- (int32_t) histogramStart
{
    return histogramStart;
}

- (void) setHistogramStart:(int32_t)aHistogramStart
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHistogramStart:histogramStart];
    
    histogramStart = aHistogramStart;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203ModelHistogramStartChanged object:self];
}

- (NSString*) shortName
{
	return @"CMC203";
}


- (uint32_t) histoDataId { return histoDataId; }
- (void) setHistoDataId: (uint32_t) aDataId
{
    histoDataId = aDataId;
}

- (uint32_t) getCounter:(int)counterTag forGroup:(int)groupTag
{
	if(groupTag == 0){
		return fifoCount;
	}
	else return 0;
}

#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setHistoMask:			[decoder decodeIntForKey:@"histoMask"]];
	[self setOperationMode:		[decoder decodeIntForKey:	@"operationMode"]];
	[self setAdcBits:			[decoder decodeIntForKey:   @"adcBits;"]];
	[self setHistogramMode:		[decoder decodeIntForKey:   @"histogramMode"]];
	[self setWordSize:			[decoder decodeIntForKey:   @"wordSize"]];
	[self setHistogramLength:	[decoder decodeIntForKey: @"histogramLength"]];
	[self setHistogramStart:	[decoder decodeIntForKey: @"histogramStart"]];
    [self setFifoRateGroup:		[decoder decodeObjectForKey:@"adcRateGroup"]];
	[self setReadOutGroup:  [decoder decodeObjectForKey:@"ReadoutGroup"]];
	
    if(!fifoRateGroup){
	    [self setFifoRateGroup:[[[ORRateGroup alloc] initGroup:1 groupTag:0] autorelease]];
	    [fifoRateGroup setIntegrationTime:5];
    }
    [self startRates];
    [fifoRateGroup resetRates];
    [fifoRateGroup calcRates];
	
	if(adcBits<8)[self setAdcBits:8];
	
	[[self undoManager] enableUndoRegistration];
	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeInt:histoMask forKey:@"histoMask"];
    [encoder encodeInteger:	  operationMode	  forKey:@"operationMode"];
    [encoder encodeInteger:	  adcBits		  forKey:@"adcBits;"];
    [encoder encodeInteger:   histogramMode   forKey:@"histogramMode"];
    [encoder encodeInteger:   wordSize		  forKey:@"wordSize"];
    [encoder encodeInt: histogramLength forKey:@"histogramLength"];
    [encoder encodeInt: histogramStart  forKey:@"histogramStart"];
    [encoder encodeObject:fifoRateGroup	  forKey:@"fifoRateGroup"];
	[encoder encodeObject:readOutGroup  forKey:@"ReadoutGroup"];
}

#pragma mark •••HW Wizard
- (int) numberOfChannels
{
	return 0;
}
- (BOOL) hasParmetersToRamp
{
	return NO;
}

- (NSArray*) wizardParameters
{
    NSMutableArray* a = [NSMutableArray array];
	
	ORHWWizParam* p = [[[ORHWWizParam alloc] init] autorelease];
     [p setName:@"Word Size"];
    [p setFormat:@"##0" upperLimit:1 lowerLimit:0 stepSize:1 units:@""];
    [p setSetMethod:@selector(setWordSize:) getMethod:@selector(wordSize)];
    [a addObject:p];

	p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Histogram Mode"];
    [p setFormat:@"##0" upperLimit:2 lowerLimit:0 stepSize:0 units:@""];
    [p setSetMethod:@selector(setHistogramMode:) getMethod:@selector(histogramMode)];
    [a addObject:p];
	
	p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Histogram Start"];
    [p setFormat:@"##0" upperLimit:0xffffffff lowerLimit:0 stepSize:1 units:@""];
    [p setSetMethod:@selector(setHistogramStart:) getMethod:@selector(histogramStart)];
    [a addObject:p];
	
	p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Histogram Length"];
    [p setFormat:@"##0" upperLimit:0xffffffff lowerLimit:0 stepSize:1 units:@""];
    [p setSetMethod:@selector(setHistogramLength:) getMethod:@selector(histogramLength)];
    [a addObject:p];
	
	p = [[[ORHWWizParam alloc] init] autorelease];
    [p setName:@"Adc Resolution"];
	OHexFormatter* aFormatter = [[[OHexFormatter alloc] init] autorelease];
    [p setFormatter:aFormatter];
    [p setSetMethod:@selector(setAdcBits:) getMethod:@selector(adcBits)];
    [a addObject:p];
	
    return a;
}

- (NSArray*) wizardSelections
{
    NSMutableArray* a = [NSMutableArray array];
    [a addObject:[ORHWWizSelection itemAtLevel:kContainerLevel name:@"Crate" className:@"ORCamacCrateModel"]];
    ORHWWizSelection* s = [ORHWWizSelection itemAtLevel:kObjectLevel name:@"Station" className:@"ORCMC203Model"];
    [a addObject:s];
    return a;
	
}
- (NSNumber*) extractParam:(NSString*)param from:(NSDictionary*)fileHeader forChannel:(int)aChannel
{
	NSDictionary* cardDictionary = [self findCardDictionaryInHeader:fileHeader];
    if([param isEqualToString:@"Histogram Start"]) return [cardDictionary objectForKey:@"histogramStart"];
    else if([param isEqualToString:@"Histogram Length"]) return [cardDictionary objectForKey:@"histogramLength"];
    else if([param isEqualToString:@"Histogram Mode"]) return [cardDictionary objectForKey:@"histogramMode"];
    else if([param isEqualToString:@"Word Size"]) return [cardDictionary objectForKey:@"wordSize"];
    else if([param isEqualToString:@"Adc Resolution"]) return [cardDictionary objectForKey:@"adcBits"];
    else if([param isEqualToString:@"Number Channels"]) return [cardDictionary objectForKey:@"numberChannels"];
    else return nil;
}

- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{
    NSMutableDictionary* objDictionary = [super addParametersToDictionary:dictionary];
	
    [objDictionary setObject:[NSNumber numberWithLong:histogramStart]	forKey:@"histogramStart"];
    [objDictionary setObject:[NSNumber numberWithLong:histogramLength]	forKey:@"histogramLength"];	
    [objDictionary setObject:[NSNumber numberWithInt:histogramMode]		forKey:@"histogramMode"];	
    [objDictionary setObject:[NSNumber numberWithInt:wordSize]			forKey:@"wordSize"];	
    [objDictionary setObject:[NSNumber numberWithInt:adcBits]			forKey:@"adcBits"];	
    return objDictionary;
}

#pragma mark •••Hardware Access
- (void) forceFPGALoad
{
	//fpga forced load sequence
	[[self adapter] camacShortNAF:[self stationNumber] a:0 f:9];  
	[[self adapter] camacShortNAF:[self stationNumber] a:0 f:30];  
	[[self adapter] camacShortNAF:[self stationNumber] a:0 f:25]; //the A led will go out after .5 sec
	[ORTimer delay:1.0];
	[[self adapter] camacShortNAF:[self stationNumber] a:0 f:9]; 
}

- (void) initBoard
{
    @try {
		unsigned short controlReg;
		[[self adapter] camacShortNAF:[self stationNumber] a:4 f:9];  //reset everything, except Histo memory
		if(operationMode == kCMC203HistogramMode){
			[[self adapter] camacShortNAF:[self stationNumber] a:42 f:9];  //reset histo memory
			
			if(wordSize == 0)	controlReg = 0x100; //16bit histograms
			else				controlReg = 0x101; //32bit histograms
			unsigned short maxAdc = powf(2.0, (float)adcBits);
			unsigned short adcMask = maxAdc-1;
			[[self adapter] camacShortNAF:[self stationNumber] a:4 f:17 data:&adcMask];
			[[self adapter] camacShortNAF:[self stationNumber] a:5 f:17 data:&maxAdc]; 
		}
		else {
			//1MB FIFO mode
			controlReg = 0x011;
		}
		[[self adapter] camacShortNAF:[self stationNumber] a:1 f:16 data:&controlReg];  
	}
	@catch(NSException* localException) {
		NSLogError(@"InitBoard",@"CMC203",nil);
		@throw;
	}
}

- (void) stopDevice
{
	[[self adapter] camacShortNAF:[self stationNumber] a:1 f:26];
}

- (void) startDevice
{
	[[self adapter] camacShortNAF:[self stationNumber] a:1 f:24];
}

- (void) sample
{
	[self stopDevice];
	[self readHistogram];
	[self startDevice];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCMC203HistoDataChangedNotification object:self];    
}

- (void) readHistogram
{
	readingHistogram = YES;
	//!!!!!Assumes that the device has been disabled
	unsigned short maxAdc = powf(2.0, (float)adcBits);								//max number of values			
	if(!histogramData) histogramData = [[NSMutableData dataWithLength:(kCMC203ReservedHistoHeaderWords + maxAdc)*sizeof(int32_t)] retain];
	[histogramData resetBytesInRange:NSMakeRange(0,[histogramData length])];

	
	unsigned short startAddress = 0;
	[[self adapter] camacShortNAF:[self stationNumber] a:1 f:17 data:&startAddress];	//load the memory start
	[[self adapter] camacShortNAF:[self stationNumber] a:5 f:17 data:&maxAdc];			//number to read
	
	int index = 0;
	uint32_t* ptr = (uint32_t*)[histogramData bytes];
	ptr[0] = histoDataId | (kCMC203ReservedHistoHeaderWords + maxAdc);
	ptr[1] = (uint32_t)((([self crateNumber]&0xf)<<21) | (([self stationNumber]& 0x0000001f)<<16));
	[[self adapter] camacLongNAF:[self stationNumber] a:10 f:2 data:&ptr[3]];		//ls histo count
	[[self adapter] camacLongNAF:[self stationNumber] a:11 f:2 data:&ptr[4]];		//ms histo count
	while(1){
		unsigned short status = [[self adapter] camacLongNAF:[self stationNumber] a:1 f:17 data:&ptr[kCMC203ReservedHistoHeaderWords+index++]];
		if(isQbitSet(status))break;
		if(index>=maxAdc)break;
	}

	readingHistogram = NO;
}

- (int) histogramCount
{
	int totalcount = (int)[histogramData length]/sizeof(int32_t);
	if(totalcount>=kCMC203ReservedHistoHeaderWords)return totalcount - kCMC203ReservedHistoHeaderWords;
	else return 0;
}

- (uint32_t) histoDataValueAtIndex:(int)index
{
	uint32_t* ptr = (uint32_t*)[histogramData bytes];
	if(ptr)return ptr[kCMC203ReservedHistoHeaderWords + index];
	else return 0;
}

#pragma mark •••DataTaker
- (void) setDataIds:(id)assigner
{
    histoDataId = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherCard
{
    [self setHistoDataId:[anotherCard histoDataId]];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
								 @"ORCMC203DecoderForHistogram",		@"decoder",
								 [NSNumber numberWithLong:histoDataId], @"histoDataId",
								 [NSNumber numberWithBool:YES],			@"variable",
								 [NSNumber numberWithLong:-1],			@"length",
								 nil];
    [dataDictionary setObject:aDictionary forKey:@"histogramData"];
	
    return dataDictionary;
}

- (void) reset
{
}

- (void) runTaskStarted:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
	
    if(![self adapter]){
		[NSException raise:@"Not Connected" format:@"You must connect to a PCI-CAMAC Controller (i.e. a CC32)."];
    }
	
	dataTakers = [[readOutGroup allObjects] retain];	//cache of data takers.
    NSEnumerator* e = [dataTakers objectEnumerator];
    id obj;
    while(obj = [e nextObject]){
        [obj runTaskStarted:aDataPacket userInfo:userInfo];
		[obj setVSN:(int)[dataTakers indexOfObject:obj]];	//put into fera mode
		[obj setFeraEnable:YES];
    }
	
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"ORCMC203Model"];    
    //----------------------------------------------------------------------------------------
	if(operationMode == kCMC203HistogramMode){
		[self clearExceptionCount];
	}
	else {
		[self startRates];
		isRunning = NO;
	}
	[self initBoard];
	[self startDevice];
	savedHeader = 0;
}

- (void) takeData:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
	if(operationMode == kCMC203FifoMode){
		isRunning = YES;
		//read the number in the fifo
		uint32_t numInFifo=0;
		unsigned short status;
		[[self adapter] camacLongNAF:[self stationNumber] a:1 f:2 data:&numInFifo];
		//read up to kMCM203MaxFifoWords
		if(numInFifo){
			uint32_t count = 0;
			do {
				uint32_t data;
				if(!savedHeader){
					status = [[self adapter] camacLongNAF:[self stationNumber] a:1 f:2 data:&data];
					if(!isQbitSet(status))break;
					count++;
				}
				else data = savedHeader;
				
				//what we do here is grab the first word, decode the vsn number
				//use it to give the proper obj its data --- let that object package and ship the data
				
				int vsn = data & 0xff;
				if(vsn<[dataTakers count]){
					id obj = [dataTakers objectAtIndex:vsn];
					
					int wordCount = (data & 0x7800) >> 11;
					if(wordCount==0)wordCount=[obj maxNumChannels];
				
					if(numInFifo < wordCount+1){
						//didn't have enough data to process, save the header and do it next time.
						savedHeader = data;
						break;
					}
					int i;
					for(i=0;i<wordCount;i++){
						uint32_t aDataWord;
						status = [[self adapter] camacLongNAF:[self stationNumber] a:1 f:2 data:&aDataWord];
						if(!isQbitSet(status))break;
						[obj shipFeraData:aDataPacket data:aDataWord];
						count++;
					}
					savedHeader = 0;
				}
				
				fifoCount++; //for the rate
			} while(count<kMCM203MaxFifoWords);
		}
	}
	else {
		//nothing to do, histogram will be read-out at end of run
	}
}

- (void) runIsStopping:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    NSEnumerator* e = [dataTakers objectEnumerator];
    id obj;
    while(obj = [e nextObject]){
        [obj runIsStopping:aDataPacket userInfo:userInfo];
    }
	if(operationMode == kCMC203HistogramMode){
		[self stopDevice];
		[self readHistogram];
		[aDataPacket addData:histogramData];
	}
}

- (BOOL) doneTakingData
{
	if(operationMode == kCMC203FifoMode) return YES;
	else								 return readingHistogram;
}

- (void) runTaskStopped:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    NSEnumerator* e = [dataTakers objectEnumerator];
    id obj;
    while(obj = [e nextObject]){
        [obj runTaskStopped:aDataPacket userInfo:userInfo];
		[obj setVSN:0]; //put into fera protocol
		[obj setFeraEnable:NO]; //put into fera protocol
    }
    [fifoRateGroup stop];
	isRunning = NO;
}

- (BOOL) bumpRateFromDecodeStage
{
	if(isRunning)return NO;
    
    ++fifoCount;
    return YES;
}

- (uint32_t) fifoCount
{
    return fifoCount;
}

-(void) startRates
{
	[self clearFifoCounts];
    [fifoRateGroup start:self];
}

- (void) clearFifoCounts
{
	fifoCount=0;
}

- (void) saveReadOutList:(NSFileHandle*)aFile
{
    [readOutGroup saveUsingFile:aFile];
}

- (void) loadReadOutList:(NSFileHandle*)aFile
{
    [self setReadOutGroup:[[[ORReadOutList alloc] initWithIdentifier:@"cPCI"]autorelease]];
    [readOutGroup loadUsingFile:aFile];
}
@end


