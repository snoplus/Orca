//--------------------------------------------------------
// ORDualPortLAMModel
// Created by Mark  A. Howe on Mon Aug 23 2004
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2004 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files


#import "ORDualPortLAMModel.h"

#import "ORReadOutList.h"
#import "OReCPU147Config.h"
#import "ORLAMhosting.h"
#import "ORVmeBusProtocol.h"

#pragma mark ***External Strings

#pragma mark ¥¥¥Notification Strings
NSString* ORDualPortLAMSlotChangedNotification	= @"ORDualPortLAMSlotChangedNotification";
NSString* ORDualPortLAMLock						= @"ORDualPortLAMLock";

@implementation ORDualPortLAMModel
- (id) init
{
	self = [super init];
    ORReadOutList* r1 = [[ORReadOutList alloc] initWithIdentifier:@"DualPort Readout"];
    [self setReadoutGroup:r1];
    [self setVariableNames:[NSMutableArray array]];
    [r1 release];
	return self;
}

- (void) dealloc
{
    [readoutGroup release];
    [variableNames release];
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"DualPortLAM"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORDualPortLAMController"];
}

- (NSString*) helpURL
{
	return @"Mac_Pci/LAM.html";
}

#pragma mark ***Accessors
- (NSString*) cardSlotChangedNotification
{
    return ORDualPortLAMSlotChangedNotification;
}

- (BOOL) acceptsGuardian: (OrcaObject *)aGuardian
{
    return [aGuardian conformsToProtocol:@protocol(ORLAMhosting)];
}

- (NSString*) identifier
{
    return [NSString stringWithFormat:@"LAM %d",[self slot]];
}

- (ORReadOutList*) readoutGroup
{
    return readoutGroup;
}

- (void) setReadoutGroup:(ORReadOutList*)newreadoutGroup
{
    [readoutGroup autorelease];
    readoutGroup=[newreadoutGroup retain];
}

- (NSMutableArray*) children 
{
    //methods exists to give common interface across all objects for display in lists
    return [NSMutableArray arrayWithObjects:readoutGroup,nil];
}


- (NSMutableArray *) variableNames
{
    return variableNames; 
}

- (void) setVariableNames: (NSMutableArray *) VariableNames
{
    [VariableNames retain];
    [variableNames release];
    variableNames = VariableNames;
}



static NSString *ORDualPortLAMSlot			= @"ORDualPortLAMSlot";
static NSString *ORDualPortLAMGroup1        = @"ORDualPortLAMGroup1";
static NSString *ORDualPortLAMVariables       = @"ORDualPortLAMVariables";

- (id)initWithCoder:(NSCoder*)decoder
{
    self = [super initWithCoder:decoder];
    
    [[self undoManager] disableUndoRegistration];
    [self setReadoutGroup:[decoder decodeObjectForKey:ORDualPortLAMGroup1]];
    [self setVariableNames:[decoder decodeObjectForKey: ORDualPortLAMVariables]];
    if(!variableNames)[self setVariableNames:[NSMutableArray array]];
    
    [self setSlot:[decoder decodeIntForKey:ORDualPortLAMSlot]];
    [[self undoManager] enableUndoRegistration];
    return self;
}



- (void)encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeObject:[self readoutGroup] forKey:ORDualPortLAMGroup1];
    [encoder encodeObject: variableNames forKey: ORDualPortLAMVariables];
    [encoder encodeInteger:[self slot] forKey:ORDualPortLAMSlot];
}

#pragma mark ***Data Taker
- (void) runTaskStarted:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    EcpuWriteLAMStruct eCpuLAMStruct;
    MacWriteLAMStruct macLAMStruct;
	memset(&eCpuLAMStruct,0,sizeof(EcpuWriteLAMStruct));
	memset(&macLAMStruct,0,sizeof(MacWriteLAMStruct));
	
	[guardian writeLongBlock:(uint32_t*)&eCpuLAMStruct
				   atAddress:MAC_DPM(ECPU_WRITE_LAM_START) + sizeof(EcpuWriteLAMStruct)*[self slot]
				  numToWrite:sizeof(EcpuWriteLAMStruct)/sizeof(int32_t)
				  withAddMod:0x09
			   usingAddSpace:0x03]; //kAccessRemoteDRAM
    
	[guardian writeLongBlock:(uint32_t*)&macLAMStruct
				   atAddress:MAC_DPM(MAC_WRITE_LAM_START) + sizeof(MacWriteLAMStruct)*[self slot]
				  numToWrite:sizeof(MacWriteLAMStruct)/sizeof(int32_t)
				  withAddMod:0x09
			   usingAddSpace:0x03]; //kAccessRemoteDRAM
    
    
	if(!started){
		dataTakers1 = [[readoutGroup allObjects] retain];	//cache of data takers.
		NSEnumerator* e = [dataTakers1 objectEnumerator];
		id obj;
		while(obj = [e nextObject]){
			[obj runTaskStarted:aDataPacket userInfo:userInfo];
		}
	}
	started = YES;
	cachedNumberOfDataTakers = (uint32_t)[dataTakers1 count];
}

- (void) saveReadOutList:(NSFileHandle*)aFile
{
    [readoutGroup saveUsingFile:aFile];
}

- (void) loadReadOutList:(NSFileHandle*)aFile
{
    [self setReadoutGroup:[[[ORReadOutList alloc] initWithIdentifier:@"Trigger 1"]autorelease]];
    [readoutGroup loadUsingFile:aFile];
}
//**************************************************************************************
// Function:	TakeData
// Description: Read data from a card
//**************************************************************************************
-(void) takeData:(ORDataPacket*)aDataPacket userInfo:(id)params
{
    NSString* errorLocation = @"";
    EcpuWriteLAMStruct eCpuLAMStruct;
    MacWriteLAMStruct macLAMStruct;
    @try {
		errorLocation = @"DualPort LAM (W)";
        [guardian readLongBlock:(uint32_t*)&eCpuLAMStruct
					  atAddress:MAC_DPM(ECPU_WRITE_LAM_START) + sizeof(EcpuWriteLAMStruct)*[self slot]
					  numToRead:sizeof(EcpuWriteLAMStruct)/sizeof(int32_t)
					 withAddMod:0x09
				  usingAddSpace:0x03]; //kAccessRemoteDRAM
        
		errorLocation = @"DualPort LAM (R)";
        [guardian readLongBlock:(uint32_t*)&macLAMStruct
					  atAddress:MAC_DPM(MAC_WRITE_LAM_START) + sizeof(MacWriteLAMStruct)*[self slot]
					  numToRead:sizeof(MacWriteLAMStruct)/sizeof(int32_t)
					 withAddMod:0x09
				  usingAddSpace:0x03]; //kAccessRemoteDRAM
        
        
		if(eCpuLAMStruct.lamFired_counter != macLAMStruct.lamAcknowledged_counter){  
            
            //check if any data for the data stream
			errorLocation = @"LAM Data Shipped";
			[aDataPacket addLongsToFrameBuffer:&eCpuLAMStruct.formatedDataWord[0] length:eCpuLAMStruct.numberDataWords];
            
            //check if any userData for the Children
            int i;
			if(!params)params = [NSMutableDictionary dictionary];
            for(i=0;i<eCpuLAMStruct.numberUserInfoWords;i++){
                if(i< [variableNames count] && [variableNames objectAtIndex:i]!=nil){
                    [params setObject:[NSNumber numberWithLong:eCpuLAMStruct.userInfoWord[i]] forKey:[variableNames objectAtIndex:i]];
                }
            }
            
            macLAMStruct.lamAcknowledged_counter = eCpuLAMStruct.lamFired_counter;
			
			errorLocation = @"Clearing LAM";
            [guardian writeLongBlock:(uint32_t*)&macLAMStruct
						   atAddress:MAC_DPM(MAC_WRITE_LAM_START) + sizeof(MacWriteLAMStruct)*[self slot]
						  numToWrite:sizeof(MacWriteLAMStruct)/sizeof(int32_t)
						  withAddMod:0x09
					   usingAddSpace:0x03]; //kAccessRemoteDRAM
            
            
			errorLocation = @"LAM Reading Children";
            for(i=0;i<cachedNumberOfDataTakers;i++){
                [[dataTakers1 objectAtIndex:i] takeData:aDataPacket userInfo:params];
            }
            
        }
        
	}
	@catch(NSException* localException) {
		NSLogError(@"",@"LAM Exception Error",errorLocation,nil);
		[localException raise];
	}
}


- (void) runTaskStopped:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
	if(started){
		NSEnumerator* e = [dataTakers1 objectEnumerator];
		id obj;
		while(obj = [e nextObject]){
			[obj runTaskStopped:aDataPacket userInfo:userInfo];
		}
		[dataTakers1 release];
		dataTakers1 = nil;
		cachedNumberOfDataTakers = 0;
	}
	started = NO;
}

- (void) reset {}

- (int) load_eCPU_HW_Config_Structure:(VME_crate_config*)configStruct index:(int)index
{
    configStruct->total_cards++;
    configStruct->card_info[index].hw_type_id = 'DLAM';             //should be unique 
    configStruct->card_info[index].hw_mask[0] 	 = -1;              //doesn't produce any records
    configStruct->card_info[index].slot 	 = [self slot];
    configStruct->card_info[index].add_mod 	 = -1;                  //not used
    configStruct->card_info[index].base_add  = -1;					//not used
	
    configStruct->card_info[index].num_Trigger_Indexes = 0;
    int nextIndex = index+1;
    
    configStruct->card_info[index].next_Card_Index 	 = nextIndex;
    
    return nextIndex;
}

@end

