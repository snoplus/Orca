//--------------------------------------------------------
// ORVmecpuModel
// Created by Mark  A. Howe on Tue Feb 07 2006
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2006 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark 본벨mported Files

#import "ORVmecpuModel.h"
#import "ORVmeCrateModel.h"
#import "ORReadOutList.h"
#import "SBC_Link.h"
#import "SBC_Config.h"
#import "ORCommandList.h"
#import "VmeSBCGeneralOperations.h"

#pragma mark 본벤xternal Strings
NSString* ORVmecpuLock = @"ORVmecpuLock";	

@implementation ORVmecpuModel
- (id) init
{
	self = [super init];
	ORReadOutList* readList = [[ORReadOutList alloc] initWithIdentifier:@"ReadOut List"];
	[self setReadOutGroup:readList];
	[readList release];
	sbcLink = [[SBC_Link alloc] initWithDelegate:self];
	return self;
}

- (void) dealloc
{
	[readOutGroup release];
	[sbcLink setDelegate:nil];
	[sbcLink release];
	[super dealloc];
}

- (void) wakeUp 
{
	[super wakeUp];
	[sbcLink wakeUp];
}

- (void) sleep 
{
	[super sleep];
	[sbcLink sleep];
}	

- (void) setUpImage
{
    [self setImage:[NSImage imageNamed:@"Vmecpu"]];
}

- (void) makeMainController
{
	[self linkToController:@"SBC_LinkController"];
}

- (NSString*) helpURL
{
	return @"VME/SBC.html";
}

- (void) awakeAfterDocumentLoaded
{
	@try {
		if(!sbcLink){
			sbcLink = [[SBC_Link alloc] initWithDelegate:self];
		}
		[sbcLink connect];
	}
	@catch(NSException* localException) {
	}
}

#pragma mark 본베ccessors

- (NSString*) shortName
{
	return @"SBC";
}

- (id) controllerCard
{
	return self;
}

- (SBC_Link*)sbcLink
{
	return sbcLink;
}

- (ORReadOutList*) readOutGroup
{
	return readOutGroup;
}
- (void) setReadOutGroup:(ORReadOutList*)newReadOutGroup
{
	[readOutGroup autorelease];
	readOutGroup=[newReadOutGroup retain];
}


- (NSMutableArray*) children {
	//method exists to give common interface across all objects for display in lists
	return [NSMutableArray arrayWithObject:readOutGroup];
}
- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{
    NSMutableDictionary* objDictionary = [super addParametersToDictionary:dictionary];
    

    [objDictionary setObject:[sbcLink sbcMacAddress] forKey:@"MacAddress"];
    [objDictionary setObject:[sbcLink IPNumber]      forKey:@"ipNumber"];
    
    
    return objDictionary;
}

#pragma mark 본벮RVmeBusProtocol Protocol
- (void) resetContrl
{
	[self reset];
}

- (void) checkStatusErrors
{
	if (![sbcLink isConnected]) {
		[NSException raise: OExceptionVmeAccessError format:@"%@",@"SBC not connected."];
	}
}

#pragma mark 본벱BC_Linking protocol
- (NSString*) driverScriptName 
{
	return @"UniverseDriverInstall";
}

- (NSString*) driverScriptInfo 
{
	return @"Install for the latest version of the Universe II driver.\n\nIf install fails you may have an older driver installed.\nTry updating the driver, reboot the sbc, then reinstall the driver again";
}

- (NSString*) cpuName
{
	return [NSString stringWithFormat:@"VME CPU (Crate %d)",[self crateNumber]];
}

- (NSString*) sbcLockName
{
	return ORVmecpuLock;
}

- (NSString*) sbcLocalCodePath
{
	return @"Source/Objects/Hardware/Vme/VMEcpu/VME_Readout_Code";
}

- (NSString*) codeResourcePath
{
	return [[self sbcLocalCodePath] lastPathComponent];
}

#pragma mark 본베rchival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	
	[self setReadOutGroup:  [decoder decodeObjectForKey:@"ReadoutGroup"]];
	
	sbcLink = [[decoder decodeObjectForKey:@"SBC_Link"] retain];
	if(!sbcLink){
		sbcLink = [[SBC_Link alloc] initWithDelegate:self];
	}
	else [sbcLink setDelegate:self];
	
	//needed only during testing because the readoutgroup was added when the object was already in the config
	if(!readOutGroup){
		ORReadOutList* readList = [[ORReadOutList alloc] initWithIdentifier:@"ReadOut List"];
		[self setReadOutGroup:readList];
		[readList release];
	}
	[[self undoManager] enableUndoRegistration];
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
	[super encodeWithCoder:encoder];
	[encoder encodeObject:readOutGroup  forKey:@"ReadoutGroup"];
	[encoder encodeObject:sbcLink		forKey:@"SBC_Link"];
}

- (void) runTaskStarted:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    [sbcLink checkSBCTime];
	dataTakers = [[readOutGroup allObjects] retain];									//cache of data takers.
	
	NSMutableDictionary* extraUserInfo = [NSMutableDictionary dictionaryWithDictionary:userInfo];		
    [extraUserInfo setObject:[NSNumber numberWithBool:YES] forKey:kSBCisDataTaker];		//tell our objects that ORCA is NOT the dataTaker
	
    NSEnumerator* e = [dataTakers objectEnumerator];
    id obj;
    while(obj = [e nextObject]){
        [obj runTaskStarted:aDataPacket userInfo:extraUserInfo];
    }
    
    //load all the data needed for the eCPU to do the HW read-out.
	[self load_HW_Config];
	[sbcLink runTaskStarted:aDataPacket userInfo:extraUserInfo];
}

-(void) takeData:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
	[sbcLink takeData:aDataPacket userInfo:userInfo];
}

- (void) runIsStopping:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    NSEnumerator* e = [dataTakers objectEnumerator];
    id obj;
    while(obj = [e nextObject]){
        [obj runIsStopping:aDataPacket userInfo:userInfo];
    }
	[sbcLink runIsStopping:aDataPacket userInfo:userInfo];
}

- (void) runTaskStopped:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    NSEnumerator* e = [dataTakers objectEnumerator];
    id obj;
    while(obj = [e nextObject]){
        [obj runTaskStopped:aDataPacket userInfo:userInfo];
    }
	[sbcLink runTaskStopped:aDataPacket userInfo:userInfo];
	[dataTakers release];
	dataTakers = nil;
}

- (BOOL) doneTakingData
{
	return [sbcLink doneTakingData];
}

- (void) saveReadOutList:(NSFileHandle*)aFile
{
    [readOutGroup saveUsingFile:aFile];
}

- (void) loadReadOutList:(NSFileHandle*)aFile
{
    [self setReadOutGroup:[[[ORReadOutList alloc] initWithIdentifier:@"cPCI"]autorelease]];
    [readOutGroup loadUsingFile:aFile];
}

- (void) reset
{
    [self performSysReset];
}

- (void) performSysReset
{
    uint32_t registerRead = 0x0;
    [self readLongBlock:&registerRead 
			  atAddress:0x404 
			  numToRead:1
			 withAddMod:0x39
		  usingAddSpace:0xFFFF];
    registerRead |= 0x404000;
    
    [self writeLongBlock:&registerRead
			   atAddress:0x404 
			  numToWrite:1
			  withAddMod:0x39
		   usingAddSpace:0xFFFF];
    
    NSLog(@"VmecpuModel (crate: %d, card: %d): Performed SYSRESET.\n", [self crateNumber], [self slot]);
}

- (void) load_HW_Config
{
	NSEnumerator* e = [dataTakers objectEnumerator];
	id obj;
	int index = 0;
	SBC_crate_config configStruct;
	
	configStruct.total_cards = 0;
	
	while(obj = [e nextObject]){
		if([obj respondsToSelector:@selector(load_HW_Config_Structure:index:)]){
			index = [obj load_HW_Config_Structure:&configStruct index:index];
		}
	}
	
	[sbcLink load_HW_Config:&configStruct];
	
}

- (int32_t) getSBCCodeVersion
{
	int32_t theVersion = 0;
	if(![sbcLink isConnected]){
		[NSException raise:@"SBC Not Connected" format:@"Socket not connected."];
	}
	else {
		[sbcLink readGeneral:&theVersion operation:kGetSoftwareVersion numToRead:1];
	}
	[sbcLink setSbcCodeVersion:theVersion];
	return theVersion;
}

-(void) readLongBlock:(uint32_t *) readAddress
			atAddress:(uint32_t) vmeAddress
			numToRead:(uint32_t) numberLongs
		   withAddMod:(unsigned short) anAddressModifier
		usingAddSpace:(unsigned short) anAddressSpace
{
	if(![sbcLink isConnected]){
		[NSException raise:@"SBC Not Connected" format:@"Socket not connected."];
	}
	[sbcLink readLongBlock:readAddress
				 atAddress:vmeAddress
				 numToRead:numberLongs
				withAddMod:anAddressModifier
			 usingAddSpace:anAddressSpace];
}

-(void) writeLongBlock:(uint32_t *) writeAddress
			 atAddress:(uint32_t) vmeAddress
			numToWrite:(uint32_t) numberLongs
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace
{
	if(![sbcLink isConnected]){
		[NSException raise:@"SBC Not Connected" format:@"Socket not connected."];
	}
	[sbcLink writeLongBlock:writeAddress
				  atAddress:vmeAddress
				 numToWrite:numberLongs
				 withAddMod:anAddressModifier
			  usingAddSpace:anAddressSpace];
	
}

/* readLong is for reading a int32_t from a single address 
 so that the address never changes, i.e. it does not
 auto-increment.  We use a specific address space to
 do this: 0xFF. */
-(void) readLong:(uint32_t *) readAddress
	   atAddress:(uint32_t) vmeAddress
	 timesToRead:(uint32_t) numberLongs
	  withAddMod:(unsigned short) anAddressModifier
   usingAddSpace:(unsigned short) anAddressSpace
{
	if(![sbcLink isConnected]){
		[NSException raise:@"SBC Not Connected" format:@"Socket not connected."];
	}
	[sbcLink readLongBlock:readAddress
				 atAddress:vmeAddress
				 numToRead:numberLongs
				withAddMod:anAddressModifier
			 usingAddSpace:0xFF];
}

-(void) readByteBlock:(unsigned char *) readAddress
			atAddress:(uint32_t) vmeAddress
			numToRead:(uint32_t) numberBytes
		   withAddMod:(unsigned short) anAddressModifier
		usingAddSpace:(unsigned short) anAddressSpace
{
	if(![sbcLink isConnected]){
		[NSException raise:@"SBC Not Connected" format:@"Socket not connected."];
	}
	[sbcLink readByteBlock:readAddress
				 atAddress:vmeAddress
				 numToRead:numberBytes
				withAddMod:anAddressModifier
			 usingAddSpace:anAddressSpace];
	
}

-(void) writeByteBlock:(unsigned char *) writeAddress
			 atAddress:(uint32_t) vmeAddress
			numToWrite:(uint32_t) numberBytes
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace
{
	if(![sbcLink isConnected]){
		[NSException raise:@"SBC Not Connected" format:@"Socket not connected."];
	}
	[sbcLink writeByteBlock:writeAddress
				  atAddress:vmeAddress
				 numToWrite:numberBytes
				 withAddMod:anAddressModifier
			  usingAddSpace:anAddressSpace];
	
}

-(void) readWordBlock:(unsigned short *) readAddress
			atAddress:(uint32_t) vmeAddress
			numToRead:(uint32_t) numberWords
		   withAddMod:(unsigned short) anAddressModifier
		usingAddSpace:(unsigned short) anAddressSpace
{
	
	if(![sbcLink isConnected]){
		[NSException raise:@"SBC Not Connected" format:@"Socket not connected."];
	}
	[sbcLink readWordBlock:readAddress
				 atAddress:vmeAddress
				 numToRead:numberWords
				withAddMod:anAddressModifier
			 usingAddSpace:anAddressSpace];
	
}

-(void) writeWordBlock:(unsigned short *) writeAddress
			 atAddress:(uint32_t) vmeAddress
			numToWrite:(uint32_t) numberWords
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace
{
	if(![sbcLink isConnected]){
		[NSException raise:@"SBC Not Connected" format:@"Socket not connected."];
	}
	[sbcLink writeWordBlock:writeAddress
				  atAddress:vmeAddress
				 numToWrite:numberWords
				 withAddMod:anAddressModifier
			  usingAddSpace:anAddressSpace];
}

- (void) executeCommandList:(ORCommandList*)aList
{
	[sbcLink executeCommandList:aList];
}

#pragma mark 본벮ROrderedObjHolding Protocol

- (int) maxNumberOfObjects	{ return 7; }
- (int) objWidth			{ return 48; }
- (int) groupSeparation		{ return 0; }

- (NSString*) nameForSlot:(int)aSlot	{ return [NSString stringWithFormat:@"LAM %d",aSlot]; }

- (BOOL) slot:(int)aSlot excludedFor:(id)anObj { return NO;}

- (NSRange) legalSlotsForObj:(id)anObj
{
	return NSMakeRange(0,[self maxNumberOfObjects]);
}
- (int) slotAtPoint:(NSPoint)aPoint 
{
	return floor(((int)aPoint.x)/[self objWidth]);
}
- (NSPoint) pointForSlot:(int)aSlot 
{
	return NSMakePoint(aSlot*[self objWidth],0);
}

- (void) place:(id)anObj intoSlot:(int)aSlot
{
	[anObj setSlot: aSlot];
	[anObj moveTo:[self pointForSlot:aSlot]];
}
- (int) slotForObj:(id)anObj
{
	return [anObj slot];
}
- (int) numberSlotsNeededFor:(id)anObj
{	
	return 1;
}
@end


