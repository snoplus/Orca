//--------------------------------------------------------
// ORRad7Model
// Created by Mark  A. Howe on Fri Jul 22 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORRad7Model.h"
#import "ORSerialPort.h"
#import "ORSerialPortList.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"
#import "ORSafeQueue.h"

#pragma mark ***External Strings
NSString* ORRad7ModelRadLinkLoadingChanged = @"ORRad7ModelRadLinkLoadingChanged";
NSString* ORRad7ModelHumidityMaxLimitChanged = @"ORRad7ModelHumidityMaxLimitChanged";
NSString* ORRad7ModelPumpCurrentMaxLimitChanged = @"ORRad7ModelPumpCurrentMaxLimitChanged";
NSString* ORRad7ModelPumpCurrentAlarmChanged = @"ORRad7ModelPumpCurrentAlarmChanged";
NSString* ORRad7ModelHumidityAlarmChanged = @"ORRad7ModelHumidityAlarmChanged";
NSString* ORRad7ModelMaxRadonChanged	= @"ORRad7ModelMaxRadonChanged";
NSString* ORRad7ModelAlarmLimitChanged	= @"ORRad7ModelAlarmLimitChanged";
NSString* ORRad7ModelMakeFileChanged	= @"ORRad7ModelMakeFileChanged";
NSString* ORRad7ModelVerboseChanged		= @"ORRad7ModelVerboseChanged";
NSString* ORRad7ModelDeleteDataOnStartChanged = @"ORRad7ModelDeleteDataOnStartChanged";
NSString* ORRad7ModelRunToPrintChanged	= @"ORRad7ModelRunToPrintChanged";
NSString* ORRad7ModelDataPointArrayChanged = @"ORRad7ModelDataPointArrayChanged";
NSString* ORRad7ModelRunStateChanged	= @"ORRad7ModelRunStateChanged";
NSString* ORRad7ModelTUnitsChanged		= @"ORRad7ModelTUnitsChanged";
NSString* ORRad7ModelRUnitsChanged		= @"ORRad7ModelRUnitsChanged";
NSString* ORRad7ModelFormatChanged		= @"ORRad7ModelFormatChanged";
NSString* ORRad7ModelToneChanged		= @"ORRad7ModelToneChanged";
NSString* ORRad7ModelPumpModeChanged	= @"ORRad7ModelPumpModeChanged";
NSString* ORRad7ModelThoronChanged		= @"ORRad7ModelThoronChanged";
NSString* ORRad7ModelModeChanged		= @"ORRad7ModelModeChanged";
NSString* ORRad7ModelRecycleChanged		= @"ORRad7ModelRecycleChanged";
NSString* ORRad7ModelCycleTimeChanged	= @"ORRad7ModelCycleTimeChanged";
NSString* ORRad7ModelProtocolChanged	= @"ORRad7ModelProtocolChanged";
NSString* ORRad7ModelPollTimeChanged	= @"ORRad7ModelPollTimeChanged";
NSString* ORRad7ModelSerialPortChanged	= @"ORRad7ModelSerialPortChanged";
NSString* ORRad7ModelPortNameChanged	= @"ORRad7ModelPortNameChanged";
NSString* ORRad7ModelPortStateChanged	= @"ORRad7ModelPortStateChanged";
NSString* ORRad7ModelStatusChanged		= @"ORRad7ModelStatusChanged";
NSString* ORRad7ModelUpdatePlot			= @"ORRad7ModelUpdatePlot";
NSString* ORRad7ModelCommandStateChanged= @"ORRad7ModelCommandStateChanged";
NSString* ORRad7ModelStatusStringChanged= @"ORRad7ModelStatusStringChanged";


NSString* ORRad7Lock = @"ORRad7Lock";

#define kMaxNumInHistory 1500


@interface ORRad7Model (private)
- (void) timeout;
- (void) process_response:(NSString*)theResponse;
- (void) handleSetupReview:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleStatusInfo:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleDataFree:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleDataCom:(NSString*)aLine lineNumber:(int) lineNumber;
- (void) handleDataRecord:(NSString*)aLine;
- (void) handleTestCom:(NSString*)aLine lineNumber:(int) lineNumber;
- (NSNumber*) getNumber:(NSString*)aString separator:(NSString*)aSeparator numberIndex:(int)anIndex;
- (NSNumber*) getNumber:(NSString*)aString separator:(NSString*)aSeparator;
- (void) startTimeOut;
- (double) convertTime:(NSArray*)parts;
- (void) resetDataSet;
- (void) clearTempVerbose;
- (void) deferredRadLinkLoad:(NSString*) contents;
- (void) resetBaudRatesAfterRadLinkLoad;
- (void) resetBaudRatesAfterRadLinkLoad2;
- (void) commandLoop;
- (void) chunkPrecheck:(NSString*)aString;
- (void) chunkPostcheck:(NSString*)aString;
- (void) flushAllCommands;
@end

@implementation ORRad7Model

#define kRad7CmdTimeout  10
#define kRad7CommErr  -999

#define kNumberRad7FormatNames 4
static NSString* rad7FormatNames[kNumberRad7FormatNames] = {
	@"OFF   ",
	@"SHORT ",
	@"MEDIUM",
	@"LONG  "
};

#define kNumberRad7ToneNames 3
static NSString* rad7ToneNames[kNumberRad7ToneNames] = {
	@"OFF   ",
	@"CHIME ",
	@"GEIGER"
};

#define kNumberRad7ModeNames 5
static NSString* rad7ModeNames[kNumberRad7ModeNames] = {
	@"SNIFF ",
	@"AUTO  ",
	@"WAT-40",
	@"WAT250",
	@"NORMAL"
};

#define kNumberRad7PumpModeNames 4
static NSString* rad7PumpModeNames[kNumberRad7PumpModeNames] = {
	@"AUTO",
	@"ON  ",
	@"OFF ",
	@"GRAB"
};

#define kNumberRad7ProtocolNames 10
static NSString* rad7ProtocolNames[kNumberRad7ProtocolNames] = {
	@"NONE  ",
	@"SNIFF ",
	@"1-DAY ",
	@"2-DAY ",
	@"WEEKS ",
	@"USER  ",
	@"GRAB  ",
	@"WAT-40",
	@"WAT250",
	@"THORON"
};

#define kNumberRad7ThoronNames 2
static NSString* rad7ThoronNames[kNumberRad7ThoronNames] = {
	@"ON ",
	@"OFF"
};
- (id) init
{
	self = [super init];
    [self registerNotificationObservers];
	gotAtLeastOneRH = NO;
	return self;
}

- (void) dealloc
{
    [dataPointArray release];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [buffer release];
	[cmdQueue release];
    [portName release];
	[stopRunFilePath release];
    if([serialPort isOpen]){
        [serialPort close];
    }
    [serialPort release];
	[statusDictionary release];
	
	[super dealloc];
}

- (void) sleep
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[super sleep];
}

- (void) wakeUp
{
	[super wakeUp];
	if(pollTime){
		[self pollHardware];
	}
    else {
        [self setStatusString:@"Idle"];
    }
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"Rad7.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORRad7Controller"];
}
- (NSString*) helpURL
{
	return @"RS232/Rad7.html";
}
- (void) registerNotificationObservers
{
	NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];
	
    [notifyCenter addObserver : self
                     selector : @selector(dataReceived:)
                         name : ORSerialPortDataReceived
                       object : nil];
}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
        if(!poweringUp && !rebooting && !radLinkLoading && !gettingData && !gettingReview) [self startTimeOut]; //reset the timeout
        
        NSString* theString = [[[[NSString alloc] initWithData:[[note userInfo] objectForKey:@"data"] 
												      encoding:NSASCIIStringEncoding] autorelease] uppercaseString];
		
        if(!buffer)buffer = [[NSMutableString string] retain];
        [buffer appendString:theString]; //accumulate into the buffer
        
        [self chunkPrecheck:buffer]; //some of the responses are very long. Check for the special cases
        
        if(gettingData){
            [self setStatusString:[NSString stringWithFormat:@"Received: %d bytes",[buffer length]]];
        }
        else if(radLinkLoading && !rebooting){
            [self setStatusString:[NSString stringWithFormat:@"Loaded: %d/%d bytes",[buffer length],radLinkSize]];
        }
        else if(gettingReview){
            [self setStatusString:[NSString stringWithFormat:@"Getting Data: %d bytes (Takes a while -- Be patient)",[buffer length]]];
        }
       
        NSUInteger eofLocation = [buffer rangeOfString:@"\r\n>"].location;
        if(eofLocation!= NSNotFound){
            //we got a '>'.
            [self chunkPostcheck:buffer]; //check that the special cases are done
            
            //take the string out of the buffer
            NSString* theResponse = [[[buffer substringToIndex:eofLocation+3] copy] autorelease];
            [buffer deleteCharactersInRange:NSMakeRange(0,eofLocation+3)];
            
            if([theResponse length] == 3){
                //case #1. Got just the '>' from sending the control-C
                //tell the state machine we got it
                gotCarrot = YES;
            }
            else {
                theResponse = [theResponse stringByReplacingOccurrencesOfString:@">" withString:@""];
                theResponse  = [theResponse stringByReplacingOccurrencesOfString:@"\n" withString:@""];
                //case #2. Got the '>' at the end of a response
                gotResponse = YES;
                [self process_response:theResponse];
                [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
            }
        }
	}
}

#pragma mark ***Accessors
- (int) commandState
{
    return commandState;
}
- (void) setCommandState:(int)aState
{
    commandState = aState;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelCommandStateChanged object:self];

}
- (NSString*)statusString
{
    if([statusString length]==0)return @"";
    else return statusString;
}

- (void) setStatusString:(NSString*)aString
{
    [statusString autorelease];
    statusString = [aString copy];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelStatusStringChanged object:self];
    
}
- (BOOL) radLinkLoading
{
    return radLinkLoading;
}

- (void) setRadLinkLoading:(BOOL)aRadLinkLoading
{
    radLinkLoading = aRadLinkLoading;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRadLinkLoadingChanged object:self];
}

- (float) humidityMaxLimit
{
    return humidityMaxLimit;
}

- (void) setHumidityMaxLimit:(float)aHumidityMaxLimit
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHumidityMaxLimit:humidityMaxLimit];
    
    humidityMaxLimit = aHumidityMaxLimit;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelHumidityMaxLimitChanged object:self];
}

- (float) pumpCurrentMaxLimit
{
    return pumpCurrentMaxLimit;
}

- (void) setPumpCurrentMaxLimit:(float)aPumpCurrentMaxLimit
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPumpCurrentMaxLimit:pumpCurrentMaxLimit];
    
    pumpCurrentMaxLimit = aPumpCurrentMaxLimit;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPumpCurrentMaxLimitChanged object:self];
}

- (float) pumpCurrentAlarm
{
    return pumpCurrentAlarm;
}

- (void) setPumpCurrentAlarm:(float)aPumpCurrentAlarm
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPumpCurrentAlarm:pumpCurrentAlarm];
    
    pumpCurrentAlarm = aPumpCurrentAlarm;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPumpCurrentAlarmChanged object:self];
}

- (float) humidityAlarm
{
    return humidityAlarm;
}

- (void) setHumidityAlarm:(float)aHumidityAlarm
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHumidityAlarm:humidityAlarm];
    
    humidityAlarm = aHumidityAlarm;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelHumidityAlarmChanged object:self];
}

- (unsigned long) maxRadon
{
    return maxRadon;
}

- (void) setMaxRadon:(unsigned long)aMaxRadon
{
    [[[self undoManager] prepareWithInvocationTarget:self] setMaxRadon:maxRadon];
    
    maxRadon = aMaxRadon;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelMaxRadonChanged object:self];
}

- (unsigned long) alarmLimit
{
    return alarmLimit;
}

- (void) setAlarmLimit:(unsigned long)aAlarmLimit
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAlarmLimit:alarmLimit];
    
    alarmLimit = aAlarmLimit;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelAlarmLimitChanged object:self];
}
- (BOOL) makeFile
{
    return makeFile;
}

- (void) setMakeFile:(BOOL)aMakeFile
{
    [[[self undoManager] prepareWithInvocationTarget:self] setMakeFile:makeFile];
    makeFile = aMakeFile;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelMakeFileChanged object:self];
}

- (BOOL) verbose
{
    return verbose;
}

- (void) setVerbose:(BOOL)aVerbose
{
    [[[self undoManager] prepareWithInvocationTarget:self] setVerbose:verbose];
    verbose = aVerbose;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelVerboseChanged object:self];
}

- (BOOL) deleteDataOnStart
{
    return deleteDataOnStart;
}

- (void) setDeleteDataOnStart:(BOOL)aDeleteDataOnStart
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDeleteDataOnStart:deleteDataOnStart];
    deleteDataOnStart = aDeleteDataOnStart;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelDeleteDataOnStartChanged object:self];
}

- (int) runToPrint
{
    return runToPrint;
}

- (void) setRunToPrint:(int)aRunToPrint
{
	if(aRunToPrint<1)aRunToPrint = 1;
	else if(aRunToPrint>99)aRunToPrint = 99;
    [[[self undoManager] prepareWithInvocationTarget:self] setRunToPrint:runToPrint];
    runToPrint = aRunToPrint;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRunToPrintChanged object:self];
}

- (NSMutableArray*) dataPointArray
{
    return dataPointArray;
}

- (void) setDataPointArray:(NSMutableArray*)anArray
{
    [anArray retain];
    [dataPointArray release];
    dataPointArray = anArray;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelDataPointArrayChanged object:self];
}

- (int) runState
{
    return runState;
}

- (void) setRunState:(int)aRunState
{
    runState = aRunState;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRunStateChanged object:self];
}

- (int) tUnits
{
    return tUnits;
}

- (void) setTUnits:(int)aUnits
{
    [[[self undoManager] prepareWithInvocationTarget:self] setTUnits:tUnits];
    tUnits = aUnits;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelTUnitsChanged object:self];
}

- (int) rUnits
{
    return rUnits;
}

- (void) setRUnits:(int)aUnits
{
    [[[self undoManager] prepareWithInvocationTarget:self] setRUnits:rUnits];
    rUnits = aUnits;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRUnitsChanged object:self];
}

- (int) formatSetting
{
    return formatSetting;
}

- (void) setFormatSetting:(int)aFormat
{
    [[[self undoManager] prepareWithInvocationTarget:self] setFormatSetting:formatSetting];
    formatSetting = aFormat;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelFormatChanged object:self];
}

- (int) tone
{
    return tone;
}

- (void) setTone:(int)aTone
{
    [[[self undoManager] prepareWithInvocationTarget:self] setTone:tone];
    tone = aTone;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelToneChanged object:self];
}

- (int) pumpMode
{
    return pumpMode;
}

- (void) setPumpMode:(int)aPumpMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPumpMode:pumpMode];
    pumpMode = aPumpMode;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPumpModeChanged object:self];
}

- (void) convertUnitsString:(NSString*)aUnitsString
{
	//should be in format like "PCI/L  `C"
	aUnitsString = [aUnitsString stringByReplacingOccurrencesOfString:@"`" withString:@""];
	aUnitsString = [aUnitsString removeExtraSpaces];
	
	NSArray* parts = [aUnitsString componentsSeparatedByString:@" "];
	if([parts count]==2){
		NSString* rU = [parts objectAtIndex:0];
		NSString* tU = [parts objectAtIndex:1];
		
		if([rU isEqualToString:@"PCI/L"])		[self setRUnits:kRad7PciL];
		else if([rU isEqualToString:@"BQ/M3"])	[self setRUnits:kRad7bqm3];
		else if([rU isEqualToString:@"CPM"])    [self setRUnits:kRad7cpm];
		else									[self setRUnits:kRad7ncnts];
		
		if([tU isEqualToString:@"C"])	[self setTUnits:kRad7Centigrade];
		else							[self setTUnits:kRad7Fahrenheit];
		
	}
}

- (int) convertFormatStringToIndex:(NSString*)aMode
{
	aMode = [aMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7FormatNames;i++){
		if([aMode isEqualToString:rad7FormatNames[i]])return i;
	}
	return 0;
}


- (int) convertToneStringToIndex:(NSString*)aMode
{
	aMode = [aMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7ToneNames;i++){
		if([aMode isEqualToString:[rad7ToneNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
}

- (int) convertModeStringToIndex:(NSString*)aMode
{
	aMode = [aMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7ModeNames;i++){
		if([aMode isEqualToString:[rad7ModeNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
}

- (int) convertPumpModeStringToIndex:(NSString*)aPumpMode
{
	aPumpMode = [aPumpMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7PumpModeNames;i++){
		if([aPumpMode isEqualToString:[rad7PumpModeNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
}

- (int) convertProtocolStringToIndex:(NSString*)aProtocol
{
	aProtocol = [aProtocol trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7ProtocolNames;i++){
		if([aProtocol isEqualToString:[rad7ProtocolNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
	
}

- (int) convertThoronStringToIndex:(NSString*)aMode
{
	aMode = [aMode trimSpacesFromEnds];
	int i;
	for(i=0;i<kNumberRad7ThoronNames;i++){
		if([aMode isEqualToString:[rad7ThoronNames[i] trimSpacesFromEnds]])return i;
	}
	return 0;
}

- (int) convertCycleHours:(NSString*)hourString minutes:(NSString*)minutesString
{
	return [hourString intValue]*60 + [minutesString intValue];
}

- (BOOL) thoron
{
    return thoron;
}

- (void) setThoron:(BOOL)aThoron
{
    [[[self undoManager] prepareWithInvocationTarget:self] setThoron:thoron];
    
    thoron = aThoron;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelThoronChanged object:self];
}

- (int) mode
{
    return mode;
}

- (void) setMode:(int)aMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setMode:mode];
    
    mode = aMode;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelModeChanged object:self];
}

- (int) recycle
{
    return recycle;
}

- (void) setRecycle:(int)aRecycle
{
	if(aRecycle < 0) aRecycle = 0;
	if(aRecycle > 99)aRecycle = 99;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setRecycle:recycle];
    
    recycle = aRecycle;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelRecycleChanged object:self];
}

- (int) cycleTime
{
    return cycleTime;
}

- (void) setCycleTime:(int)aCycleTime
{
	if(aCycleTime<0)aCycleTime=1;
	else if(aCycleTime> 24*60)aCycleTime=24*60;
    [[[self undoManager] prepareWithInvocationTarget:self] setCycleTime:cycleTime];
    
    cycleTime = aCycleTime;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelCycleTimeChanged object:self];
}

- (int) protocol
{
    return protocol;
}

- (void) setProtocol:(int)aProtocol
{
    [[[self undoManager] prepareWithInvocationTarget:self] setRad7Protocol:protocol];
    protocol = aProtocol;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelProtocolChanged object:self];
}

- (void) setRad7Protocol:(int)aProtocol
{
    [self setProtocol:aProtocol];
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPollTimeChanged object:self];
	
	if(pollTime){
		[self performSelector:@selector(pollHardware) withObject:nil afterDelay:2];
	}
	else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	}
}

- (unsigned long) timeMeasured
{
	return timeMeasured;
}

- (BOOL) portWasOpen
{
    return portWasOpen;
}

- (void) setPortWasOpen:(BOOL)aPortWasOpen
{
    portWasOpen = aPortWasOpen;
}

- (NSString*) portName
{
    return portName;
}

- (void) setPortName:(NSString*)aPortName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];    
		
        BOOL valid = NO;
        NSEnumerator *enumerator = [ORSerialPortList portEnumerator];
        ORSerialPort *aPort;
        while (aPort = [enumerator nextObject]) {
            if([portName isEqualToString:[aPort name]]){
                [self setSerialPort:aPort];
                if(portWasOpen){
                    [self openPort:YES];
				}
                valid = YES;
                break;
            }
        } 
        if(!valid){
            [self setSerialPort:nil];
        }       
    }
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPortNameChanged object:self];
}

- (ORSerialPort*) serialPort
{
    return serialPort;
}

- (void) setSerialPort:(ORSerialPort*)aSerialPort
{
    [aSerialPort retain];
    [serialPort release];
    serialPort = aSerialPort;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelSerialPortChanged object:self];
}

- (void) openPort:(BOOL)state
{
    if(state) {
        [serialPort open];
		[serialPort setSpeed:9600];
		[serialPort setParityNone];
		[serialPort setStopBits2:NO];
		[serialPort setDataBits:8];
		[serialPort commitChanges];
    }
    else [serialPort close];
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelPortStateChanged object:self];
}

- (NSDictionary*) statusDictionary
{
	return statusDictionary;
}



#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setHumidityMaxLimit:	[decoder decodeFloatForKey:@"humidityMaxLimit"]];
	[self setPumpCurrentMaxLimit:[decoder decodeFloatForKey:@"pumpCurrentMaxLimit"]];
	[self setPumpCurrentAlarm:	[decoder decodeFloatForKey:@"pumpCurrentAlarm"]];
	[self setHumidityAlarm:		[decoder decodeFloatForKey:@"humidityAlarm"]];
	[self setMaxRadon:			[decoder decodeInt32ForKey:@"maxRadon"]];
	[self setAlarmLimit:		[decoder decodeInt32ForKey:@"alarmLimit"]];
	[self setMakeFile:			[decoder decodeBoolForKey:	@"makeFile"]];
	[self setVerbose:			[decoder decodeBoolForKey:	@"verbose"]];
	[self setDeleteDataOnStart:	[decoder decodeBoolForKey:	@"deleteDataOnStart"]];
	[self setRunToPrint:		[decoder decodeIntForKey:	@"runToPrint"]];
	[self setTUnits:			[decoder decodeIntForKey:	@"tUnits"]];
	[self setRUnits:			[decoder decodeIntForKey:	@"rUnits"]];
	[self setFormatSetting:		[decoder decodeIntForKey:	@"formatSetting"]];
	[self setTone:				[decoder decodeIntForKey:	@"tone"]];
	[self setPumpMode:			[decoder decodeIntForKey:	@"pumpMode"]];
	[self setThoron:			[decoder decodeBoolForKey:	@"thoron"]];
	[self setMode:				[decoder decodeIntForKey:	@"mode"]];
	[self setRecycle:			[decoder decodeIntForKey:	@"recycle"]];
	[self setCycleTime:			[decoder decodeIntForKey:	@"cycleTime"]];
	[self setProtocol:			[decoder decodeIntForKey:	@"protocol"]];
	[self setPollTime:			[decoder decodeIntForKey:	@"ORRad7ModelPollTime"]];
	[self setPortWasOpen:		[decoder decodeBoolForKey:	@"ORRad7ModelPortWasOpen"]];
    [self setPortName:			[decoder decodeObjectForKey:@"portName"]];
	[[self undoManager] enableUndoRegistration];
	
    [self registerNotificationObservers];
	
	gotAtLeastOneRH = NO;
	
	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeFloat:	humidityMaxLimit	forKey:@"humidityMaxLimit"];
    [encoder encodeFloat:	pumpCurrentMaxLimit forKey:@"pumpCurrentMaxLimit"];
    [encoder encodeFloat:	pumpCurrentAlarm forKey:@"pumpCurrentAlarm"];
    [encoder encodeFloat:	humidityAlarm	forKey:@"humidityAlarm"];
    [encoder encodeInt32:	maxRadon		forKey:@"maxRadon"];
    [encoder encodeInt32:	alarmLimit		forKey:@"alarmLimit"];
    [encoder encodeBool:	makeFile		forKey:@"makeFile"];
    [encoder encodeBool:	verbose			forKey:@"verbose"];
    [encoder encodeBool:	deleteDataOnStart forKey:@"deleteDataOnStart"];
    [encoder encodeInt:		runToPrint		forKey:@"runToPrint"];
    [encoder encodeInt:		rUnits			forKey: @"rUnits"];
    [encoder encodeInt:		tUnits			forKey: @"tUnits"];
    [encoder encodeInt:		formatSetting	forKey: @"formatSetting"];
    [encoder encodeInt:		tone			forKey: @"tone"];
    [encoder encodeInt:		pumpMode		forKey: @"pumpMode"];
    [encoder encodeBool:    thoron			forKey: @"thoron"];
    [encoder encodeInt:     mode			forKey: @"mode"];
    [encoder encodeInt:     recycle			forKey: @"recycle"];
    [encoder encodeInt:     cycleTime		forKey: @"cycleTime"];
    [encoder encodeInt:		protocol		forKey: @"protocol"];
    [encoder encodeInt:		pollTime		forKey:	@"ORRad7ModelPollTime"];
    [encoder encodeBool:	portWasOpen		forKey:	@"ORRad7ModelPortWasOpen"];
    [encoder encodeObject:	portName		forKey: @"portName"];
}

- (id) history
{
	//our base class calls history when saving this object's history
	return dataPointArray;
}

- (void) setHistory:(id)someHistory
{
	//our base class calls setHistory when loading this object's history
	[self setDataPointArray:someHistory];
}

- (void) deleteHistory
{
	[super deleteHistory];
	[self setDataPointArray:nil];
}

#pragma mark *** Commands
- (void) addCmdToQueue:(NSString*)aCmd
{
    if([serialPort isOpen]){
		if(!cmdQueue)cmdQueue = [[ORSafeQueue alloc] init];
        aCmd = [aCmd stringByReplacingOccurrencesOfString:@"\n" withString:@""];
        aCmd = [aCmd stringByReplacingOccurrencesOfString:@"\r" withString:@""];
        aCmd = [aCmd stringByAppendingString:@"\r\n"];
        
		[cmdQueue enqueue:aCmd];
        if(commandState == kRad7QueueIdle){
            commandState = kRad7SendCntrlC;
            [self commandLoop];
        }
	}
}

- (void) specialStart
{
	NSLog(@"Starting %@\n",[self fullID]);
	[self setRunState:kRad7RunStateUnKnown];
	if(deleteDataOnStart)	{
		[self resetDataSet];
		[self addCmdToQueue:@"DATA ERASE YES"];
	}
	[self initHardware];
	[self addCmdToQueue:@"SPECIAL START"];
	[self addCmdToQueue:@"SPECIAL STATUS"];
}

- (void) specialStop
{
    NSLog(@"Stopping %@\n",[self fullID]);
	[self setRunState:kRad7RunStateUnKnown];
	[self addCmdToQueue:@"SPECIAL STOP"];
	[self addCmdToQueue:@"SPECIAL STATUS"];
}

- (void) specialStatus
{
	[self addCmdToQueue:@"SPECIAL STATUS"];
	[self addCmdToQueue:@"DATA FREE"];
}

- (void) dataErase
{
	[self addCmdToQueue:@"DATA ERASE YES"];
}

- (void) dataDelete:(int) runNumber
{
	if(runNumber>0 && runNumber < 99){
		[self addCmdToQueue:[NSString stringWithFormat: @"DATA DELETE %02d",runNumber]];
		[self addCmdToQueue:@"YES"];
		[self addCmdToQueue:@"DATA RENUMBER"];
	}
	else NSLog(@"Rad7: runNumber for dataDelete must be between 0 and 99 inclusive\n");
}

- (void) printDataInProgress
{
	tempVerbose = YES;
	[self addCmdToQueue:@"TEST COM"];	
}

- (void) printRun
{
	tempVerbose = YES;
	[self printRun:runToPrint];
}

- (void) printRun:(int) runNumber
{
	if(runNumber>0 && runNumber < 99){
		[self addCmdToQueue:[NSString stringWithFormat: @"DATA COM %02d",runNumber]];
	}
	else NSLog(@"Rad7: runNumber for dataCom must be between 0 and 99 inclusive\n");
}

- (void) setupCycle
{
	int hours = cycleTime/60;
	int minutes = cycleTime - hours*60;
	NSString* cycleString = [NSString stringWithFormat:@"%02d:%02d",hours,minutes];
	[self addCmdToQueue:[NSString stringWithFormat: @"SETUP CYCLE %@",cycleString]];
}

- (void) setupUnits
{
	NSString* unitString = @"";
	switch (rUnits){
		case 0: unitString = [unitString stringByAppendingString: @"PCI/L"]; break;
		case 1: unitString = [unitString stringByAppendingString: @"BQ/M3"]; break;
		case 2: unitString = [unitString stringByAppendingString: @"CPM  "]; break;
		default: unitString = [unitString stringByAppendingString:@"#CNTS"]; break;
	}
	unitString = [unitString stringByAppendingString:@" "];
	switch (tUnits){
		case 0: unitString = [unitString stringByAppendingString: @"C"]; break;
		default: unitString = [unitString stringByAppendingString:@"F"]; break;
	}
	
	[self addCmdToQueue:[NSString stringWithFormat: @"SETUP UNITS %@",unitString]];
}

- (void) saveUser
{
	[self addCmdToQueue:[NSString stringWithFormat: @"SETUP SAVUSER YES"]];
}

- (void) setupRecycle
{
	[self addCmdToQueue:[NSString stringWithFormat: @"SETUP RECYCLE %d",recycle]];
}

- (void) setupMode
{
	if(mode >= 0 && mode <kNumberRad7ModeNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP MODE %@",rad7ModeNames[mode]]];
	}
}
- (void) setupProtocol
{
	if(protocol >= 0 && protocol <kNumberRad7ProtocolNames){
		NSString* paramString;
		if(protocol == 0) paramString = @"(NONE)";
		else paramString = rad7ProtocolNames[protocol];
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP PROTOCOL %@",paramString]];
	}
}
- (void) setupThoron
{
	if(thoron >= 0 && thoron <kNumberRad7ThoronNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP THORON %@",rad7ThoronNames[thoron]]];
	}
}
- (void) setupPumpMode
{
	if(pumpMode >= 0 && pumpMode <kNumberRad7PumpModeNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP PUMP %@",rad7PumpModeNames[pumpMode]]];
	}
}

- (void) setupTone
{
	if(tone >= 0 && tone <kNumberRad7ToneNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP TONE %@",rad7ToneNames[tone]]];
	}
}

- (void) setupFormat
{
	if(formatSetting >= 0 && formatSetting <kNumberRad7FormatNames){
		[self addCmdToQueue:[NSString stringWithFormat: @"SETUP FORMAT %@",rad7FormatNames[formatSetting]]];
	}
}

- (void) loadDialogFromHardware
{
    [self addCmdToQueue:@"SETUP REVIEW"];
    NSLog(@"Getting settings from Rad7.... Takes a long time... Be Patient.\n");
}

- (void) initHardware
{
	[self setupProtocol];
	if(protocol == kRad7ProtocolNone){
		[self setupMode];
		[self setupPumpMode];
		[self setupThoron];
		[self setupRecycle];
		[self setupCycle];
	}
	[self setupTone];
	[self setupFormat];
	[self setupUnits];
}

- (id) statusForKey:(id)aKey
{
	id aValue = [statusDictionary objectForKey:aKey];
	if(!aValue) return @"-";
	else return aValue;
}

- (void) pollHardware
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	[self specialStatus];
	if(pollTime){
		[self performSelector:@selector(pollHardware) withObject:nil afterDelay:pollTime];
	}
}

- (int) numPoints
{
	return [dataPointArray count];
}

- (double) radonValue:(int)index
{
	if(index<[dataPointArray count]){
		return [(ORRad7DataPt*)[dataPointArray objectAtIndex:index] value];
	}
	else return 0;
}

- (double) radonTime:(int)index
{
	if(index<[dataPointArray count]){
		return (double)[[dataPointArray objectAtIndex:index] time];
	}
	else return 0;
}

- (double) rhValue:(int)index
{
	if(index<[dataPointArray count]){
		return (double)[[dataPointArray objectAtIndex:index] rh];
	}
	else return 0;
}

#pragma mark •••Bit Processing Protocol
- (void) processIsStarting
{
}

- (void) processIsStopping
{
}

//note that everything called by these routines MUST be threadsafe
- (void) startProcessCycle
{    
}

- (void) endProcessCycle
{
}

- (NSString*) identifier
{
	NSString* s;
 	@synchronized(self){
		s= [NSString stringWithFormat:@"Rad7,%lu",[self uniqueIdNumber]];
	}
	return s;
}

- (NSString*) processingTitle
{
	NSString* s;
 	@synchronized(self){
		s= [self identifier];
	}
	return s;
}

- (double) convertedValue:(int)aChan
{
	double theValue = 0;
	@synchronized(self){
		switch(aChan){
			case 0: theValue = 	[[statusDictionary objectForKey:kRad7LastRadon]  doubleValue];	break;
			case 1: theValue = 	[[statusDictionary objectForKey:kRad7RH]		  doubleValue];	break;
			case 2: theValue = 	[[statusDictionary objectForKey:kRad7PumpCurrent] doubleValue];	break;
		}
	}
	return theValue;
}

- (double) maxValueForChan:(int)aChan
{
	double theValue = 0;
	@synchronized(self){
		switch(aChan){
			case 0: theValue = (double)[self maxRadon];				break;
			case 1: theValue = (double)[self humidityMaxLimit];     break;
			case 2: theValue = (double)[self pumpCurrentMaxLimit];	break;
		}
	}
	return theValue;
}

- (double) minValueForChan:(int)aChan
{
	return 0;
}

- (void) getAlarmRangeLow:(double*)theLowLimit high:(double*)theHighLimit channel:(int)aChan
{
	@synchronized(self){
		*theLowLimit = -.001;
		
		switch(aChan){
			case 0: *theHighLimit =  [self alarmLimit];			break;
			case 1: *theHighLimit =  [self humidityAlarm];		break;
			case 2: *theHighLimit =  [self pumpCurrentAlarm];	break;
			default: *theHighLimit = 1.0E20; //some random very large number
		}
	}		
}

- (BOOL) processValue:(int)channel
{
	BOOL r;
	@synchronized(self){
		r = [[statusDictionary objectForKey:kRad7RunStatus] boolValue];
	}
	return r;
}

- (void) setProcessOutput:(int)channel value:(int)value
{
    //nothing to do
}

- (BOOL) dataForChannelValid:(int)aChannel
{
    return dataValid && [serialPort isOpen];
}

- (void) loadRadLinkFile:(NSString*)filePath index:(int)index;
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
    
	NSString* contents = [NSString stringWithContentsOfFile:filePath encoding:NSASCIIStringEncoding error:nil];
    radLinkSize = [contents length];
    [self flushAllCommands];
    if([contents length]){
        [self setRadLinkLoading:YES];
        if(index==0){
            if(![serialPort isOpen])[self openPort:YES];
            [serialPort setSpeed:1200];
            [serialPort setParityNone];
            [serialPort setStopBits2:NO];
            [serialPort setDataBits:8];
            [serialPort commitChanges];
            okCount = 0;
            
            NSLog(@"%@: Loading RadLink file: %@. Will reboot Rad7 after loading.\n",[self fullID],[filePath stringByAbbreviatingWithTildeInPath]);
        }
        else {
            NSLog(@"%@: Turning off polling\n",[self fullID]);
            [self setPollTime:0];
            [serialPort writeString:@"SPECIAL S-Load\r\n"];

            NSLog(@"%@: UnLoading RadLink. Communication will be impossible until radLink is reloaded\n",[self fullID]);
            unLoading = YES;
        }
       [self performSelector:@selector(deferredRadLinkLoad:) withObject:contents afterDelay:2];
    }
    else {
        NSLog(@"%@: <%@> was empty.. nothing to load\n",[self fullID],[filePath stringByAbbreviatingWithTildeInPath]);
    }
}
- (void) stopOpsAndInterrupt
{
    NSLog(@"Manual Interrupt of %@\n",[self fullID]);
    NSLog(@"Buffer Cleared of %d bytes\n",[buffer length]);
    [self flushAllCommands];

    [serialPort writeString:[NSString stringWithFormat:@"%c",0x03]];
    [self setStatusString:@"Idle"];
}
@end

@implementation ORRad7Model (private)
- (void) resetDataSet
{
	[self setDataPointArray:nil];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelUpdatePlot 
														object:self];
}
- (void) deferredRadLinkLoad:(NSString *)contents
{
    [serialPort writeString:contents];
}

- (void) resetBaudRatesAfterRadLinkLoad
{
    //after a RadLink load the Rad7 is at 1200 baud. We have to reset our serial port to 1200 baud
    //and then reset the Rad7 to 9600 and then reset the serial port back to 9600
    if(![serialPort isOpen])[self openPort:YES];
    [serialPort setSpeed:1200];	//reset our port
    [serialPort setParityNone];
    [serialPort setStopBits2:NO];
    [serialPort setDataBits:8];
    [serialPort commitChanges];
    
    [serialPort writeString:@"Special setbaud 9600\r\n"];
    
    [self performSelector:@selector(resetBaudRatesAfterRadLinkLoad2) withObject:nil afterDelay:2];
}

- (void) resetBaudRatesAfterRadLinkLoad2
{
    [serialPort setSpeed:9600];	//reset our port
    [serialPort setParityNone];
    [serialPort setStopBits2:NO];
    [serialPort setDataBits:8];
    [serialPort commitChanges];
    [self performSelector:@selector(deferredPollHardware) withObject:nil afterDelay:2];
}

- (void) deferredPollHardware
{
    [self flushAllCommands];
	[self pollHardware];
}


- (void) timeout
{
    dataValid = NO;
	NSLogError(@"command timeout",@"Rad7",nil);
    [self setStatusString:@"Timed out. No Response."];
    [self flushAllCommands];
}

- (void) clearTempVerbose
{
	tempVerbose = NO;
}

- (void) process_response:(NSString*)theResponse
{
    
    if([theResponse length]!=0){
        
        dataValid = YES;
        if([theResponse rangeOfString:@"?ERR" options:NSCaseInsensitiveSearch].location != NSNotFound){
            tempVerbose = NO;
            [self flushAllCommands];
            
            NSLogError(@"",@"Comm Error",@"Rad7",[NSString stringWithFormat:@"unit %lu",[self uniqueIdNumber]],nil);

            id runStateString = [statusDictionary objectForKey:kRad7RunStatus];
            
            if(!runStateString)								 [self setRunState:kRad7RunStateUnKnown];
            else if([runStateString isEqualToString:@"LIVE"])[self setRunState:kRad7RunStateCounting];
            else											 [self setRunState:kRad7RunStateStopped];
            
            [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelStatusChanged object:self];
        }
        else if([theResponse rangeOfString:@"SPECIAL STATUS"].location != NSNotFound){
            NSArray* lines = [theResponse componentsSeparatedByString:@"\r"];
            int lineNumber = 0;
            for(id aLine in lines){
                [self handleStatusInfo:aLine lineNumber:lineNumber++];
            }
            
            id runStateString = [statusDictionary objectForKey:kRad7RunStatus];
            
            if(!runStateString)								 [self setRunState:kRad7RunStateUnKnown];
            else if([runStateString isEqualToString:@"LIVE"])[self setRunState:kRad7RunStateCounting];
            else											 [self setRunState:kRad7RunStateStopped];


        }
        else if([theResponse rangeOfString:@"DATA FREE"].location != NSNotFound){
            NSArray* lines = [theResponse componentsSeparatedByString:@"\r"];
            int lineNumber = 0;
            for(id aLine in lines){
                [self handleDataFree:aLine lineNumber:lineNumber++];
            }
        }
        else if([theResponse rangeOfString:@"SETUP REVIEW"].location != NSNotFound){
            NSArray* lines = [theResponse componentsSeparatedByString:@"\r"];
            int lineNumber = 0;
            for(id aLine in lines){
                [self handleSetupReview:aLine lineNumber:lineNumber++];
            }
        }
        else if([theResponse rangeOfString:@"DATA COM"].location != NSNotFound){
            NSArray* lines = [theResponse componentsSeparatedByString:@"\r"];
            int lineNumber = 0;
            for(id aLine in lines){
                [self handleDataCom:aLine lineNumber:lineNumber++];
            }
        }
        else if([theResponse rangeOfString:@"TEST COM"].location != NSNotFound){
            NSArray* lines = [theResponse componentsSeparatedByString:@"\r"];
            int lineNumber = 0;
            for(id aLine in lines){
                [self handleTestCom:aLine lineNumber:lineNumber++];
            }
        }
    }
    if(pollTime)[self performSelector:@selector(pollHardware) withObject:nil afterDelay:pollTime];
   
    [[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelStatusChanged object:self];
}

- (void) flushAllCommands
{
    [cmdQueue removeAllObjects];
    [buffer release];
    buffer = nil;
    commandState = kRad7Idle;
    [self commandLoop];
}

- (void) handleDataRecord:(NSString*)aLine
{
	NSArray* parts = [aLine componentsSeparatedByString:@","];
	if([parts count] >= 23){
		if(dataRecordCount == 0){
			[self setDataPointArray:[NSMutableArray array]];
			if(makeFile){
				[stopRunFilePath release];
				stopRunFilePath = [NSString stringWithFormat:@"~/Desktop/Rad7/Rad7_%lu_%@",[self uniqueIdNumber],[NSDate date]];
				stopRunFilePath = [stopRunFilePath stringByExpandingTildeInPath];
				stopRunFilePath = [stopRunFilePath stringByReplacingOccurrencesOfString:@" " withString:@"_"];
				stopRunFilePath = [stopRunFilePath stringByReplacingOccurrencesOfString:@"-" withString:@"_"];
				stopRunFilePath = [stopRunFilePath stringByReplacingOccurrencesOfString:@":" withString:@"_"];
				NSRange r = [stopRunFilePath rangeOfString:@"__"];
				if(r.location!=NSNotFound)stopRunFilePath = [stopRunFilePath substringToIndex:r.location];
				[stopRunFilePath retain];
				NSLog(@"Rad 7 data logged to file: %@\n",stopRunFilePath);
			}
			if(verbose  || tempVerbose){
				unsigned int unitsWord = [[parts objectAtIndex:22] intValue] & 0x3; //Units
				NSString* unitsString = @"";
				if(unitsWord == 0x0)unitsString = @"CPM";
				else if(unitsWord == 0x1)unitsString = @"#Counts";
				else if(unitsWord == 0x2)unitsString = @"Bq/m^3";
				else if(unitsWord == 0x3)unitsString = @"pCi/L";
				
				NSLogFont([NSFont fontWithName:@"Monaco" size:11], @"Cycle Date   Time  Counts  LT  A(%%)  B(%%)  C(%%)  D(%%)    Radon (%@)\n",unitsString);
				NSLogFont([NSFont fontWithName:@"Monaco" size:11], @"----------------------------------------------------------------------------\n");
			}
		}
		NSString* s = [NSString stringWithFormat:@"%3d %02d/%02d/%02d %02d:%02d %4d %5.1f %5.1f %5.1f %5.1f %5.1f %9.4f +- %9.4f",
					   [[parts objectAtIndex:0] intValue], //test number
					   [[parts objectAtIndex:3] intValue], //day
					   [[parts objectAtIndex:2] intValue], //month
					   [[parts objectAtIndex:1] intValue], //year
					   [[parts objectAtIndex:4] intValue], //hour
					   [[parts objectAtIndex:5] intValue], //minutes
					   [[parts objectAtIndex:6] intValue], //Total Counts
					   [[parts objectAtIndex:7] floatValue], //Live Time
					   [[parts objectAtIndex:8] floatValue], //% in A
					   [[parts objectAtIndex:9] floatValue], //% in B
					   [[parts objectAtIndex:10] floatValue], //% in C
					   [[parts objectAtIndex:11] floatValue], //% in C
					   [[parts objectAtIndex:20] floatValue], //Radon
					   [[parts objectAtIndex:21] floatValue] //UnCertainty
					   ];
		if(verbose || tempVerbose){			
			NSLogFont([NSFont fontWithName:@"Monaco" size:11], @"%@\n",s);
		}
		
		if(makeFile){
			//reformat for file
			s = [s removeExtraSpaces];
			s = [s stringByReplacingOccurrencesOfString:@" " withString:@","];
			s = [s stringByReplacingOccurrencesOfString:@",+-," withString:@","];
			
			NSFileManager* fm = [NSFileManager defaultManager];
			
			if(![fm fileExistsAtPath:stopRunFilePath]){
				NSString* dirPath = [stopRunFilePath stringByDeletingLastPathComponent];
				[fm createDirectoryAtPath:dirPath withIntermediateDirectories:YES attributes:nil error:nil];        
				[fm createFileAtPath:stopRunFilePath contents:nil attributes:nil];
			}
			NSFileHandle* fh = [NSFileHandle fileHandleForUpdatingAtPath:stopRunFilePath];
			[fh seekToEndOfFile];
			s = [s stringByAppendingString:@"\n"];
			[fh writeData:[s dataUsingEncoding:NSASCIIStringEncoding]];
			[fh closeFile];
		}
		
		dataRecordCount++;

	}
}

- (double) convertTime:(NSArray*)parts
{
	int day = [[parts objectAtIndex:3] intValue]; //day
	int month = [[parts objectAtIndex:2] intValue]; //month
	int year = [[parts objectAtIndex:1] intValue]; //year
	int hour = [[parts objectAtIndex:4] intValue]; //hour
	int minute = [[parts objectAtIndex:5] intValue]; //minutes
	NSString *dateStr = [NSString stringWithFormat:@"20%02d%02d%02d %02d:%02d",year,month,day,hour,minute];
	
	// Convert string to date object
	NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];
	[dateFormat setDateFormat:@"yyyyMMdd HH:mm"];
	NSDate *date = [dateFormat dateFromString:dateStr];  
	NSTimeInterval t1 = [date timeIntervalSince1970];
	[dateFormat release];
	return (double)t1;
}

- (void) handleTestCom:(NSString*)aLine lineNumber:(int) lineNumber
{
	if(lineNumber == 0){
		NSLog(@"Rad7: Incomplete Test Data Follows\n");		
		dataRecordCount = 0;
        gettingData = YES;
	}
    else if(lineNumber > 1){
        NSLog(@"%@\n",aLine);
    }
}

- (void) handleDataCom:(NSString*)aLine lineNumber:(int) lineNumber
{
	if(lineNumber <= 2){
        dataRecordCount = 0;
        if([aLine hasPrefix:@"NO"]){
            NSLog(@"%@ -- No Data Stored\n",[self fullID]);
        }
	}
    else {
        [self handleDataRecord:aLine];
    }
}

- (void) handleDataFree:(NSString*)aLine lineNumber:(int) lineNumber
{
	if(!statusDictionary) statusDictionary = [[NSMutableDictionary dictionary] retain];
	if(lineNumber == 2){
		if([aLine rangeOfString:@"CYCLES FREE" options:NSCaseInsensitiveSearch].location != NSNotFound){
			int freeCycles = [aLine intValue];
			[statusDictionary setObject:[NSNumber numberWithInt:freeCycles] forKey:kRad7FreeCycles];
		}
	}
}

- (void) handleStatusInfo:(NSString*)aLine lineNumber:(int) lineNumber
{
    aLine = [aLine removeExtraSpaces];
    if([aLine length]==0)return;
	if(!statusDictionary) statusDictionary = [[NSMutableDictionary dictionary] retain];
	if(lineNumber < 2)return; //don't care about these
	else if(lineNumber == 2){
		//arghhh -- some of the states don't have spaces between the fields
		aLine = [aLine stringByReplacingOccurrencesOfString:@"WAT-40" withString:@"WAT40 "];
		aLine = [aLine stringByReplacingOccurrencesOfString:@"WAT250" withString:@"WAT250 "];
		aLine = [aLine stringByReplacingOccurrencesOfString:@"NORMAL" withString:@"NORMAL "];
		NSArray* parts = [aLine componentsSeparatedByString:@" "];
		if([parts count] == 5){
			int thisRunNum = [[[parts objectAtIndex:0] substringToIndex:2] intValue];
			int thisCycleNum = [[[parts objectAtIndex:0] substringFromIndex:2] intValue];
			id lastRunStatus = [self statusForKey:kRad7RunStatus];
			id newRunStatus  = [parts objectAtIndex:1];
			if(lastRunStatus && newRunStatus && ![lastRunStatus isEqualToString:newRunStatus] && ![lastRunStatus isEqualToString:@"-"]){
				if([lastRunStatus length] && [newRunStatus isEqualToString:@"IDLE"]){
					runEnded = YES;
				}
			}
			[statusDictionary setObject:[NSNumber numberWithInt:thisRunNum]    forKey:kRad7RunNumber];
			[statusDictionary setObject:[NSNumber numberWithInt:thisCycleNum]  forKey:kRad7CycleNumber];
			[statusDictionary setObject:[parts objectAtIndex:1] forKey:kRad7RunStatus];
			[statusDictionary setObject:[parts objectAtIndex:2] forKey:kRad7RunPumpStatus];
			[statusDictionary setObject:[parts objectAtIndex:3] forKey:kRad7RunCountDown];
			[statusDictionary setObject:[parts objectAtIndex:4] forKey:kRad7NumberCounts];
		}
		else {
			[statusDictionary setObject:@"--" forKey:kRad7CycleNumber];
			[statusDictionary setObject:@"--" forKey:kRad7RunStatus];
			[statusDictionary setObject:@"--" forKey:kRad7RunPumpStatus];
			[statusDictionary setObject:@"--" forKey:kRad7RunCountDown];
			[statusDictionary setObject:@"--" forKey:kRad7NumberCounts];
		}
	}
	
	else if(lineNumber == 3){
		if([aLine rangeOfString:@"LAST READING: " options:NSCaseInsensitiveSearch].location != NSNotFound){
			aLine = [aLine substringFromIndex:14];
			if([aLine rangeOfString:@"NO TESTS STORED" options:NSCaseInsensitiveSearch].location == NSNotFound){
				aLine = [aLine stringByReplacingOccurrencesOfString:@"+- " withString:@"+-"];
				aLine = [aLine stringByReplacingOccurrencesOfString:@" +-" withString:@"+-"];
				
				NSArray* parts = [aLine componentsSeparatedByString:@" "];
				if([parts count] >= 3){
					int thisRunNum = [[[parts objectAtIndex:0] substringToIndex:2] intValue];
					int thisCycleNum = [[[parts objectAtIndex:0] substringFromIndex:2] intValue];
					int lastRunNum = [[statusDictionary objectForKey:kRad7LastRunNumber] intValue];
					int lastCycleNum = [[statusDictionary objectForKey:kRad7LastCycleNumber] intValue];
					
					[statusDictionary setObject:[[parts objectAtIndex:0] substringToIndex:2]    forKey:kRad7LastRunNumber];
					[statusDictionary setObject:[[parts objectAtIndex:0] substringFromIndex:2]  forKey:kRad7LastCycleNumber];
					NSArray* readingParts = [[parts objectAtIndex:1] componentsSeparatedByString:@"+-"];
					if([readingParts count] >= 2){
						float lastRadon        = [[readingParts objectAtIndex:0] floatValue];
						float lastUncertainty  = [[readingParts objectAtIndex:1] floatValue];
						[statusDictionary setObject:[NSNumber numberWithFloat:lastRadon]  forKey:kRad7LastRadon];
						[statusDictionary setObject:[NSNumber numberWithFloat:lastUncertainty]  forKey:kRad7LastRadonUncertainty];
						[statusDictionary setObject:[parts objectAtIndex:2]  forKey:kRad7LastRadonUnits];
						
						if((thisRunNum!=lastRunNum || thisCycleNum!=lastCycleNum) && gotAtLeastOneRH){
							if(!dataPointArray){
								[self setDataPointArray:[NSMutableArray array]];
							}
							ORRad7DataPt* aPt = [[[ORRad7DataPt alloc] init] autorelease];
							NSDate *date = [NSDate date];  
							NSTimeInterval t1 = [date timeIntervalSince1970];
							
							[aPt setTime:t1];
							[aPt setValue:lastRadon];
							[aPt setRh:    [[self statusForKey:kRad7RH] floatValue]];
							[dataPointArray addObject:aPt];
							if([dataPointArray count]>kMaxNumInHistory)[dataPointArray removeObjectsInRange:NSMakeRange(0,500)];
							
							[[NSNotificationCenter defaultCenter] postNotificationName:ORRad7ModelUpdatePlot 
																				object:self];
							[self saveHistory];
						}
						
					}
				}
			}
			else {
				[statusDictionary setObject:@"--"  forKey:kRad7LastRunNumber];
				[statusDictionary setObject:@"--"  forKey:kRad7LastCycleNumber];
				[statusDictionary setObject:@"--"  forKey:kRad7LastRadon];
				[statusDictionary setObject:@"--"  forKey:kRad7LastRadonUncertainty];
				[statusDictionary setObject:@"-"  forKey:kRad7LastRadonUnits];
			}
		}
	}
	
	else if(lineNumber == 4){
		aLine = [aLine stringByReplacingOccurrencesOfString:@": " withString:@":"];
		NSArray* parts = [aLine componentsSeparatedByString:@" "];
		if([parts count] == 4){
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:0] separator:@"`"] forKey:kRad7Temp];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:1] separator:@":" numberIndex:1] forKey:kRad7RH];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:2] separator:@":" numberIndex:1] forKey:kRad7Battery];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:3] separator:@":" numberIndex:1] forKey:kRad7PumpCurrent];
			NSArray* temperatureParts = [[parts objectAtIndex:0] componentsSeparatedByString:@"`"];
			if([temperatureParts count]==2)[statusDictionary setObject:[temperatureParts objectAtIndex:1] forKey:kRad7TempUnits];
			else [statusDictionary setObject:@"" forKey:kRad7TempUnits];
			gotAtLeastOneRH = YES; //prevents a zero rh at the start of ORCA
		}
		else {
			[statusDictionary setObject:@"--" forKey:kRad7Temp];
			[statusDictionary setObject:@"--" forKey:kRad7RH];
			[statusDictionary setObject:@"--" forKey:kRad7Battery];
			[statusDictionary setObject:@"--" forKey:kRad7PumpCurrent];
		}
	}
	
	else if(lineNumber == 5){
		aLine = [aLine stringByReplacingOccurrencesOfString:@": " withString:@":"];
		NSArray* parts = [aLine componentsSeparatedByString:@" "];
		if([parts count] == 4){
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:0] separator:@":" numberIndex:1] forKey:kRad7HV];
			[statusDictionary setObject:[NSNumber numberWithInt:[[parts objectAtIndex:1] intValue]] forKey:kRad7DutyCycle];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:2] separator:@":" numberIndex:1] forKey:kRad7LeakageCurrent];
			[statusDictionary setObject:[self getNumber:[parts objectAtIndex:3] separator:@":" numberIndex:1] forKey:kRad7SignalVoltage];
			if(runEnded){
				if(verbose || makeFile  || tempVerbose){
					int theRunNumber = [[self statusForKey:kRad7LastRunNumber] intValue];
					if(theRunNumber>=1){
						[self printRun:theRunNumber];
					}
					else {
						NSLog(@"Rad7: No data available\n");
					}
				}
				runEnded = NO;
			}
		}
		else {
			[statusDictionary setObject:@"--" forKey:kRad7Temp];
			[statusDictionary setObject:@"--" forKey:kRad7RH];
			[statusDictionary setObject:@"--" forKey:kRad7Battery];
			[statusDictionary setObject:@"--" forKey:kRad7PumpCurrent];
		}
	}
}

- (NSNumber*) getNumber:(NSString*)aString separator:(NSString*)aSeparator
{
	return [self getNumber:aString separator:aSeparator numberIndex:0];
}

- (NSNumber*) getNumber:(NSString*)aString separator:(NSString*)aSeparator numberIndex:(int)anIndex
{
	NSArray* parts = [aString componentsSeparatedByString:aSeparator];
	if([parts count] > anIndex){
		return [NSNumber numberWithFloat:[[parts objectAtIndex:anIndex] floatValue]];
	}
	else return [NSNumber numberWithInt:0];
	
}

- (void) handleSetupReview:(NSString*)aLine lineNumber:(int) lineNumber
{
	if(lineNumber < 4)return; //don't care about these
	if([aLine rangeOfString:@":"].location != NSNotFound){
		NSArray* parts = [aLine componentsSeparatedByString:@":"];
		if([parts count]>=2){
			NSString* tag   = [[parts objectAtIndex:0] trimSpacesFromEnds];
			NSString* value = [[parts objectAtIndex:1] trimSpacesFromEnds];
			NSString* value1 = @"";
			if([parts count]>=3)value1 = [[parts objectAtIndex:2] trimSpacesFromEnds];

				if([tag isEqualToString:@"PUMP"])[self setPumpMode:[self convertPumpModeStringToIndex:value]];
				else if([tag isEqualToString:@"MODE"])[self setMode:[self convertModeStringToIndex:value]];
				else if([tag isEqualToString:@"THORON"])[self setThoron:[self convertThoronStringToIndex:value]];
				else if([tag isEqualToString:@"RECYCLE"])[self setRecycle:[value intValue]];
				else if([tag isEqualToString:@"CYCLE"])[self setCycleTime:[self convertCycleHours:value minutes:value1]];
				else if([tag isEqualToString:@"TONE"])[self setTone:[self convertToneStringToIndex:value]];
				else if([tag isEqualToString:@"FORMAT"])[self setFormatSetting:[self convertFormatStringToIndex:value]];
				else if([tag isEqualToString:@"PROTOCOL"])[self setProtocol:[self convertProtocolStringToIndex:value]];
				else if([tag isEqualToString:@"UNITS"])[self convertUnitsString:value];
			}
		
	}
}

- (void) startTimeOut
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	[self performSelector:@selector(timeout) withObject:nil afterDelay:kRad7CmdTimeout];
}

- (void) commandLoop
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(commandLoop) object:nil];
    switch (commandState) {
        case kRad7SendCntrlC:
            if([cmdQueue count]){
                gotCarrot = NO;
                [serialPort writeString:[NSString stringWithFormat:@"%c",0x03]];
                [self setStatusString:@"Sending Cntrl-C"];
                [self startTimeOut];
                commandState = kRad7WaitForCarrot;
            }
            else {
                commandState = kRad7QueueIdle;
                [self setStatusString:@"Idle"];
            }
        break;
        
        case kRad7WaitForCarrot:
            if(gotCarrot){
                NSString* aCmd = [cmdQueue dequeue];
                if(aCmd){
                    gotResponse = NO;
                    commandState = kRad7WaitForResponse;
                    [serialPort writeString:aCmd];
                    [self setStatusString:[NSString stringWithFormat:@"Sending Command: %@",aCmd]];
                    [self startTimeOut];
                }
                else {
                    commandState = kRad7QueueIdle;
                    [self setStatusString:@"Idle"];
               }
            }
        break;
        
        case kRad7WaitForResponse:
            if(gotResponse){
                commandState = kRad7SendCntrlC;
            }
        break;
    }
    if(commandState != kRad7QueueIdle){
        [self performSelector:@selector(commandLoop) withObject:self afterDelay:.1];
    }
}
- (void) chunkPrecheck:(NSString*)aString
{
    if(radLinkLoading){
        if([aString rangeOfString:@"OK." options:NSCaseInsensitiveSearch].location != NSNotFound){
            [buffer release];
            buffer = nil;
            if(unLoading){
                [self setRadLinkLoading:NO];
                NSLog(@"%@: RadLink done unloading\n",[self fullID]);
                unLoading = NO;
                [self setStatusString:@"RadLink unloaded. No Communication Possible"];
            }
            else {
                NSLog(@"%@: RadLink done loading\n",[self fullID]);
                NSLog(@"%@: Waiting until reboot is finished\n",[self fullID]);
                [self setStatusString:@"Download finished. Rebooting in a few seconds."];
                rebooting = YES;
           }
        }
        else if([aString rangeOfString:@"DURRIDGE"].location != NSNotFound){
            [buffer release];
            buffer = nil;
            tempVerbose = NO;
            NSLog(@"%@ Starting Reboot.\n",[self fullID]);
            [self setStatusString:@"Starting Reboot"];
        }
        else if([aString rangeOfString:@"Units" options:NSCaseInsensitiveSearch].location != NSNotFound){
             [buffer release];
             buffer = nil;
             NSLog(@"%@: Reboot is finished\n",[self fullID]);
             [self setStatusString:@"Reboot Done"];
             [self setRadLinkLoading:NO];
             rebooting = NO;
            [self performSelector:@selector(resetBaudRatesAfterRadLinkLoad) withObject:nil afterDelay:2];
        }
    }
    else {
        if([aString rangeOfString:@"DURRIDGE"].location != NSNotFound){
            if(!poweringUp){
                tempVerbose = NO;
                poweringUp = YES;
                [self flushAllCommands];
                NSLog(@"%@ going thru power up -- all queued commands cleared\n",[self fullID]);
                [self setStatusString:@"Going phru power up cycle"];
            }
        }
        else if([aString rangeOfString:@"Units" options:NSCaseInsensitiveSearch].location != NSNotFound){
            if(poweringUp)NSLog(@"%@: Reboot is finished\n",[self fullID]);
        }
        else if([aString rangeOfString:@"DATA COM"].location != NSNotFound){
            gettingData = YES;
        }
        else if([aString rangeOfString:@"SETUP REVIEW"].location != NSNotFound){
            gettingReview = YES;
        }
    }
  }

- (void) chunkPostcheck:(NSString*)aString
{
    if(poweringUp){
        poweringUp = NO;
        NSLog(@"%@ power up sequence has finished\n",[self fullID]);
        [self setStatusString:@"Idle"];
        poweringUp = NO;
        [buffer release];
        buffer = nil;
    }
    else if(gettingData){
        gettingData = NO;
        [self setStatusString:@"Idle"];
    }
    else if(gettingReview){
        gettingReview = NO;
        [self setStatusString:@"Idle"];
    }
}

@end

@implementation ORRad7DataPt
@synthesize value,time,rh;
#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{	
	@try {
		[self setTime:		[decoder decodeDoubleForKey:@"time"]];
		[self setValue:		[decoder decodeDoubleForKey:@"value"]];
		[self setRh:		[decoder decodeDoubleForKey:@"rh"]];
	}
	@catch (NSException* e) {
		NSLog(@"Exception storing the Rad7 Data History. %@\n",e);
	}
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
	@try {
		[encoder encodeDouble:	time	forKey:@"time"];
		[encoder encodeDouble:	value	forKey:@"value"];
		[encoder encodeDouble:	rh		forKey:@"rh"];
	}
	@catch (NSException* e) {
		NSLog(@"Exception loading the Rad7 Data History. %@\n",e);
	}
}
@end
