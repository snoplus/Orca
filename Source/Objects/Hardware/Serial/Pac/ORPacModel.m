//--------------------------------------------------------
// ORPacModel
// Created by Mark  A. Howe on Tue Jan 6, 2009
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of
//Washington at the Center for Experimental Nuclear Physics and
//Astrophysics (CENPA) sponsored in part by the United States
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020.
//The University has certain rights in the program pursuant to
//the contract and the program should not be copied or distributed
//outside your organization.  The DOE and the University of
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty,
//express or implied, or assume any liability or responsibility
//for the use of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORPacModel.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORSerialPortList.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"
#import "ORDataSet.h"
#import "ORTimeRate.h"
#import "ORAlarm.h"
#import "ORSafeQueue.h"

#pragma mark •••External Strings
NSString* ORPacModelLastGainReadChanged = @"ORPacModelLastGainReadChanged";
NSString* ORPacModelAdcChannelChanged   = @"ORPacModelAdcChannelChanged";
NSString* ORPacModelLcmChanged          = @"ORPacModelLcChanged";
NSString* ORPacModelProcessLimitsChanged = @"ORPacModelProcessLimitsChanged";
NSString* ORPacModelGainDisplayTypeChanged = @"ORPacModelGainDisplayTypeChanged";
NSString* ORPacModelSetAllGainsChanged  = @"ORPacModelSetAllGainsChanged";
NSString* ORPacModelGainChannelChanged  = @"ORPacModelGainChannelChanged";
NSString* ORPacModelLcmEnabledChanged	= @"ORPacModelLcmEnabledChanged";
NSString* ORPacModelPreAmpChanged		= @"ORPacModelPreAmpChanged";
NSString* ORPacModelModuleChanged		= @"ORPacModelModuleChanged";
NSString* ORPacModelGainValueChanged		= @"ORPacModelGainValueChanged";
NSString* ORPacModelSerialPortChanged	= @"ORPacModelSerialPortChanged";
NSString* ORPacModelPortNameChanged		= @"ORPacModelPortNameChanged";
NSString* ORPacModelPortStateChanged	= @"ORPacModelPortStateChanged";
NSString* ORPacModelAdcChanged			= @"ORPacModelAdcChanged";
NSString* ORPacLock						= @"ORPacLock";
NSString* ORPacModelGainsChanged		= @"ORPacModelGainsChanged";
NSString* ORPacModelPollingStateChanged	= @"ORPacModelPollingStateChangedNotification";
NSString* ORPacModelMultiPlotsChanged	= @"ORPacModelMultiPlotsChanged";
NSString* ORPacModelLogToFileChanged	= @"ORPacModelLogToFileChanged";
NSString* ORPacModelLogFileChanged		= @"ORPacModelLogFileChanged";
NSString* ORPacModelQueCountChanged		= @"ORPacModelQueCountChanged";
NSString* ORPacModelGainsReadBackChanged= @"ORPacModelGainsReadBackChanged";
NSString* ORPacModelVetoChanged			= @"ORPacModelVetoChanged";

@interface ORPacModel (private)
- (void) timeout;
- (void) processOneCommandFromQueue;
- (void) _setUpPolling:(BOOL)verbose;
- (void) _stopPolling;
- (void) _startPolling;
- (void) _pollAllChannels;
- (void) shipAdcValues;
- (void) loadLogBuffer;
- (void) checkVetoCondition;
@end

#define kBadPacValue -999

@implementation ORPacModel
- (id) init
{
	self = [super init];
    [self registerNotificationObservers];
    gainBuffer = nil;
	lcmEnabled = YES; //inverted in HW.
	return self;
}

- (void) dealloc
{
    [lastGainRead release];
    [lastGainFile release];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [buffer release];
	[cmdQueue release];
	[lastRequest release];
    [portName release];
    if([serialPort isOpen]){
        [serialPort close];
    }
	[serialPort setDelegate:nil];
	[serialPort release];
	[inComingData release];
	
    [logFile release];
	[self _stopPolling];
	
	int i;
	for(i=0;i<8;i++){
		[timeRates[i] release];
	}
	[processLimits release];
    [lcmEnabledAlarm clearAlarm];
	[lcmEnabledAlarm release];
	
	[[ORGlobal sharedGlobal] removeRunVeto:@"LCM Enabled"];
	
	[super dealloc];
}

- (void) wakeUp
{
    if(![self aWake]){
		//[self _setUpPolling:NO];
		if(logToFile){
			[self performSelector:@selector(writeLogBufferToFile) withObject:nil afterDelay:60];
		}
    }
	[self checkVetoCondition];
    [super wakeUp];
}

- (void) sleep
{
	[[ORGlobal sharedGlobal] removeRunVeto:@"LCM Enabled"];
    [super sleep];
    // [NSObject cancelPreviousPerformRequestsWithTarget:self];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"Pac.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORPacController"];
}

- (void) registerNotificationObservers
{
	NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];
    
    [notifyCenter addObserver : self
                     selector : @selector(dataReceived:)
                         name : ORSerialPortDataReceived
                       object : nil];
}

#pragma mark •••Accessors
- (NSDate*) lastGainRead
{
    return lastGainRead;
}

- (void) setLastGainRead:(NSDate*)aLastGainRead
{
    [aLastGainRead retain];
    [lastGainRead release];
    lastGainRead = aLastGainRead;
    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelLastGainReadChanged object:self];
}
- (int) calculateAdcChannel
{
    return module*8 + preAmp;
}

- (int) calculateModule
{
    return adcChannel/8;
}

- (int) calculatePreamp
{
    return adcChannel%8;
}

- (int) adcChannel
{
    return adcChannel;
}

- (void) setAdcChannel:(int)aAdcChannel
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAdcChannel:adcChannel];
    
    adcChannel = aAdcChannel;
    module = [self calculateModule];
    preAmp = [self calculatePreamp];
    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelAdcChannelChanged object:self];
}

- (int) preAmp
{
    return preAmp;
}

- (void) setPreAmp:(int)aPreAmp
{
    if(aPreAmp<0)aPreAmp = 0;
    else if(aPreAmp > 0x7) aPreAmp = 0x7; //3 bits
    [[[self undoManager] prepareWithInvocationTarget:self] setPreAmp:preAmp];
    preAmp = aPreAmp;
    adcChannel = [self calculateAdcChannel];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelPreAmpChanged object:self];
}

- (int) module
{
    return module;
}

- (void) setModule:(int)aModule
{
    if(aModule<0)aModule = 0;
    else if(aModule > 0x1f) aModule = 0x1f; //five bits
    
    [[[self undoManager] prepareWithInvocationTarget:self] setModule:module];
    module = aModule;
    adcChannel = [self calculateAdcChannel];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelModuleChanged object:self];
}

- (unsigned short) lcmTimeMeasured
{
    return lcmTimeMeasured;
}

- (unsigned short) lcm
{
    return lcm;
}

- (void) setLcm:(unsigned short)aLcm
{
    lcm = aLcm;
    //get the time(UT!)
    time_t	ut_Time;
    time(&ut_Time);
    //struct tm* theTimeGMTAsStruct = gmtime(&theTime);
    lcmTimeMeasured = ut_Time;
    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelLcmChanged object:self];
}

- (NSMutableArray*) processLimits
{
    return processLimits;
}

- (NSString*) lastGainFile
{
    return lastGainFile;
}

- (void) setLastGainFile:(NSString*)aLastGainFile
{
    [lastGainFile autorelease];
    lastGainFile = [aLastGainFile copy];
}

- (int) gainDisplayType
{
    return gainDisplayType;
}

- (void) setGainDisplayType:(int)aGainDisplayType
{
    [[[self undoManager] prepareWithInvocationTarget:self] setGainDisplayType:gainDisplayType];
    gainDisplayType = aGainDisplayType;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelGainDisplayTypeChanged object:self];
}

- (int) queCount
{
	return [cmdQueue count];
}

- (BOOL) readingTemperatures
{
    return [self lcmEnabled]; //the logic got inverted somewhere.
}

- (ORTimeRate*)timeRate:(int)index
{
	return timeRates[index];
}

- (int)  gain:(int)index
{
	if(index>=0 && index<148)return gain[index];
	else return 0;
}

- (void) setGain:(int)index withValue:(int)aValue
{
	if(index>=0 && index<148){
		[[[self undoManager] prepareWithInvocationTarget:self] setGain:index withValue:gain[index]];
		gain[index] = aValue;
		[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelGainsChanged object:self];
	}
}

- (int)  gainReadBack:(int)index
{
	if(index>=0 && index<148)return gainReadBack[index];
	else return 0;
}

- (void) setGainReadBack:(int)index withValue:(int)aValue
{
	if(index>=0 && index<148){
		gainReadBack[index] = aValue;
		[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelGainsReadBackChanged object:self];
	}
}

- (BOOL) setAllGains
{
    return setAllGains;
}

- (void) setSetAllGains:(BOOL)aSetAllGains
{
    [[[self undoManager] prepareWithInvocationTarget:self] setSetAllGains:setAllGains];
    setAllGains = aSetAllGains;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelSetAllGainsChanged object:self];
}

- (int) gainChannel
{
    return gainChannel;
}

- (void) setGainChannel:(int)aGainChannel
{
	if(aGainChannel<0)aGainChannel=0;
	if(aGainChannel>147)aGainChannel=147;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setGainChannel:gainChannel];
    gainChannel = aGainChannel;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelGainChannelChanged object:self];
}

- (BOOL) lcmEnabled
{
    return lcmEnabled;
}

- (void) setLcmEnabled:(BOOL)aLcmEnabled
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLcmEnabled:lcmEnabled];
    lcmEnabled = aLcmEnabled;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelLcmEnabledChanged object:self];
	[self checkVetoCondition];
}


- (int) gainValue
{
    return gainValue;
}

- (void) setGainValue:(int)aGainValue
{
	if(aGainValue>256)aGainValue=255;
    [[[self undoManager] prepareWithInvocationTarget:self] setGainValue:gainValue];
    gainValue = aGainValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelGainValueChanged object:self];
}

- (float) lcmVoltage
{
	return 5.0 * lcm/65535.0;
}

- (float) adcVoltage:(int)index
{
	if(index<0 && index>=8)return 0.0;
	else return 5.0 * adc[index]/65535.0;
}

- (float) convertedLcm
{
 	float theValue = kBadPacValue; //a 'bad' value as default
	@synchronized (self){
        if(![self readingTemperatures]){
            float leakageCurrentConstants[2] = {1.0	,	0.0};
            float voltage = [self lcmVoltage];
            theValue = voltage * leakageCurrentConstants[0] + leakageCurrentConstants[1];
        }
    }
    return theValue;
}

- (float) convertedAdc:(int)index
{
	float theValue = kBadPacValue; //a 'bad' value as default
	@synchronized (self){
		if(index<0 && index>8)return 0.0;
        
		float temperatureConstants[8][2] = {
			{100.0	,	-50.0},
			{1.0	,	0.0},
			{1.0	,	0.0},
			{1.0	,	0.0},
			{1.0	,	0.0},
			{1.0	,	0.0},
			{86.141	,	-100},
			{1.0	,	0.0},
		};
        
		float voltage = [self adcVoltage:index];
		if(index>=0 && index<8) {
            theValue = voltage * temperatureConstants[index][0] + temperatureConstants[index][1];
            if(index==0 && ![self readingTemperatures]) theValue = kBadPacValue;
        }
	}
	return theValue;
}

- (unsigned short) adc:(int)index
{
	if(index>=0 && index<8)return adc[index];
	else return 0.0;
}

- (void) setAdc:(int)index value:(unsigned short)aValue
{
	if(index>=0 && index<8){
		adc[index] = aValue;
		//get the time(UT!)
		time_t	ut_Time;
		time(&ut_Time);
		//struct tm* theTimeGMTAsStruct = gmtime(&theTime);
		timeMeasured[index] = ut_Time;
		
		[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelAdcChanged
															object:self
                                                          userInfo:[NSDictionary dictionaryWithObject:[NSNumber numberWithInt:index] forKey:@"Index"]];
        
		if(timeRates[index] == nil) timeRates[index] = [[ORTimeRate alloc] init];
		[timeRates[index] addDataToTimeAverage:[self convertedAdc:index]];
	}
}

- (NSData*) lastRequest
{
	return lastRequest;
}

- (void) setLastRequest:(NSData*)aRequest
{
	[aRequest retain];
	[lastRequest release];
	lastRequest = aRequest;
}

- (BOOL) portWasOpen
{
    return portWasOpen;
}

- (void) setPortWasOpen:(BOOL)aPortWasOpen
{
    portWasOpen = aPortWasOpen;
}

- (NSString*) portName
{
    return portName;
}

- (void) setPortName:(NSString*)aPortName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];
        
        BOOL valid = NO;
        NSEnumerator *enumerator = [ORSerialPortList portEnumerator];
        ORSerialPort *aPort;
        while (aPort = [enumerator nextObject]) {
            if([portName isEqualToString:[aPort name]]){
                [self setSerialPort:aPort];
                if(portWasOpen){
                    [self openPort:YES];
                }
                valid = YES;
                break;
            }
        }
        if(!valid){
            [self setSerialPort:nil];
        }
    }
    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelPortNameChanged object:self];
}

- (ORSerialPort*) serialPort
{
    return serialPort;
}

- (void) setSerialPort:(ORSerialPort*)aSerialPort
{
    [aSerialPort retain];
    [serialPort release];
    serialPort = aSerialPort;
    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelSerialPortChanged object:self];
}

- (void) openPort:(BOOL)state
{
    if(state) {
        [serialPort open];
		[serialPort setSpeed:9600];
		[serialPort setParityNone];
		[serialPort setStopBits2:NO];
		[serialPort setDataBits:8];
		[serialPort commitChanges];
		[serialPort setDelegate:self];
    }
    else      [serialPort close];
    portWasOpen = [serialPort isOpen];
    [self checkVetoCondition];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelPortStateChanged object:self];
}

- (BOOL) isConnected
{
    return [serialPort isOpen];
}

- (NSString*) logFile
{
    return logFile;
}

- (void) setLogFile:(NSString*)aLogFile
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLogFile:logFile];
	
    [logFile autorelease];
    logFile = [aLogFile copy];
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelLogFileChanged object:self];
}

- (BOOL) logToFile
{
    return logToFile;
}

- (void) setLogToFile:(BOOL)aLogToFile
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLogToFile:logToFile];
    
    logToFile = aLogToFile;
	
	if(logToFile)[self performSelector:@selector(writeLogBufferToFile) withObject:nil afterDelay:60];
	else {
		[logBuffer removeAllObjects];
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(writeLogBufferToFile) object:nil];
	}
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelLogToFileChanged object:self];
}

- (void) writeLogBufferToFile
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(writeLogBufferToFile) object:nil];
	if(logToFile && [logBuffer count] && [logFile length]){
		if(![[NSFileManager defaultManager] fileExistsAtPath:[logFile stringByExpandingTildeInPath]]){
			[[NSFileManager defaultManager] createFileAtPath:[logFile stringByExpandingTildeInPath] contents:nil attributes:nil];
		}
		
		NSFileHandle* fh = [NSFileHandle fileHandleForUpdatingAtPath:[logFile stringByExpandingTildeInPath]];
		[fh seekToEndOfFile];
		
		int i;
		int n = [logBuffer count];
		for(i=0;i<n;i++){
			[fh writeData:[[logBuffer objectAtIndex:i] dataUsingEncoding:NSASCIIStringEncoding]];
		}
		[fh closeFile];
		[logBuffer removeAllObjects];
	}
	[self performSelector:@selector(writeLogBufferToFile) withObject:nil afterDelay:60];
}


#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
    gainBuffer = nil;
    
	[[self undoManager] disableUndoRegistration];
    
    processLimits = [[decoder decodeObjectForKey:@"processLimits"]retain];
    if(!processLimits)[self setProcessLimitDefaults];
    //--------------------------------------------------------------
	[self setLastGainFile:	[decoder decodeObjectForKey: @"lastGainFile"]];
	[self setGainDisplayType:[decoder decodeIntForKey:   @"gainDisplayType"]];
	[self setSetAllGains:	[decoder decodeBoolForKey:	 @"ORPacModelSetAllGains"]];
	[self setGainChannel:	[decoder decodeIntForKey:	 @"ORPacModelGainChannel"]];
	[self setLcmEnabled:	[decoder decodeBoolForKey:	 @"ORPacModelLcmEnabled"]];
	[self setPreAmp:		[decoder decodeIntForKey:	 @"ORPacModelPreAmp"]];
	[self setModule:		[decoder decodeIntForKey:	 @"ORPacModelModule"]];
	[self setGainValue:		[decoder decodeIntForKey:	 @"gainValue"]];
	[self setPortWasOpen:	[decoder decodeBoolForKey:	 @"portWasOpen"]];
	[self setPollingState:	[decoder decodeIntForKey:	 @"pollingState"]];
	[self setLogFile:		[decoder decodeObjectForKey: @"logFile"]];
    [self setLogToFile:		[decoder decodeBoolForKey:	 @"logToFile"]];
	[self setAdcChannel:    [decoder decodeIntForKey:    @"ORPacModelAdcChannel"]];
	
    int i;
	for(i=0;i<8;i++){
		timeRates[i] = [[ORTimeRate alloc] init];
	}
	for(i=0;i<148;i++){
		[self setGain:i withValue: [decoder decodeIntForKey:[NSString stringWithFormat:@"gain%d",i]]];
	}
    
    [self setPortName:		[decoder decodeObjectForKey: @"portName"]];
    
	[[self undoManager] enableUndoRegistration];
    [self registerNotificationObservers];
    
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeObject:processLimits     forKey:@"processLimits"];
    [encoder encodeObject:lastGainFile  forKey:@"lastGainFile"];
    [encoder encodeInt:gainDisplayType  forKey:@"gainDisplayType"];
    [encoder encodeBool:setAllGains		forKey:@"ORPacModelSetAllGains"];
    [encoder encodeInt:gainChannel		forKey:@"ORPacModelGainChannel"];
    [encoder encodeBool:lcmEnabled		forKey:@"ORPacModelLcmEnabled"];
    [encoder encodeInt:preAmp			forKey:@"ORPacModelPreAmp"];
    [encoder encodeInt:module			forKey:@"ORPacModelModule"];
    [encoder encodeInt:gainValue			forKey:@"gainValue"];
    [encoder encodeBool:portWasOpen		forKey:@"portWasOpen"];
    [encoder encodeObject:portName		forKey:@"portName"];
    [encoder encodeInt:pollingState		forKey:@"pollingState"];
    [encoder encodeObject:logFile		forKey:@"logFile"];
    [encoder encodeBool:logToFile		forKey:@"logToFile"];
    [encoder encodeInt:adcChannel       forKey:@"ORPacModelAdcChannel"];
	int i;
	for(i=0;i<148;i++){
		[encoder encodeInt:gain[i] forKey: [NSString stringWithFormat:@"gain%d",i]];
	}
}


#pragma mark ••• Commands
- (void) writeLcmEnable
{
    if([serialPort isOpen]){
		char cmdData[2];
		cmdData[0] = kPacLcmEnaCmd;
		cmdData[1] = ([self lcmEnabled]?kPacLcmEnaSet:kPacLcmEnaClr);
		[self writeCmdData:[NSData dataWithBytes:cmdData length:2]];
	}
}
- (void) writeModuleSelect
{
    if([serialPort isOpen]){
		char cmdData[2];
		cmdData[0] = kPacSelCmd; //module select
		cmdData[1] = (module << 3) | (preAmp & 0x7);
		[self writeCmdData:[NSData dataWithBytes:cmdData length:2]];
	}
}

- (void) writeReadADC:(int)aChannel
{
    if([serialPort isOpen]){
		char cmdData[2];
		cmdData[0] = kPacADCmd;
		cmdData[1] = aChannel;
		[self writeCmdData:[NSData dataWithBytes:cmdData length:2]];
	}
}


- (void) writeOneGain:(int)index
{
    if([serialPort isOpen]){
		if(index>=0 && index<148){
			char cmdData[5];
			cmdData[0] = kPacGainCmd;
			cmdData[1] = kPacGainWriteOneGain;
			cmdData[2] = index+1;
			cmdData[3] = 0x10 | ((gain[index] & 0xf0)>>4);
			cmdData[4] = (gain[index] & 0x0f)<<4;
			[self writeCmdData:[NSData dataWithBytes:cmdData length:5]];
		}
	}
}


- (void) writeReadGain
{
    if([serialPort isOpen]){
		char cmdData[3];
		cmdData[0] = kPacGainCmd;
		cmdData[1] = kPacGainReadOneGain;
		cmdData[2] = gainChannel+1;
		[self writeCmdData:[NSData dataWithBytes:cmdData length:3]];
	}
}

- (void) writeReadAllGains
{
    if([serialPort isOpen]){
		char cmdData[3];
		cmdData[0] = kPacGainCmd;
		cmdData[1] = kPacGainReadAll;
		[self writeCmdData:[NSData dataWithBytes:cmdData length:2]];
	}
}


- (void) writeShipCmd
{
    if([serialPort isOpen]){
		char theCommand = kPacShipAdcs;
		[self writeCmdData:[NSData dataWithBytes:&theCommand length:1]];
	}
}

- (void) writeCmdData:(NSData*)someData
{
	if(!cmdQueue)cmdQueue = [[ORSafeQueue alloc] init];
	[cmdQueue enqueue:someData];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelQueCountChanged object: self];
	if(!lastRequest)[self processOneCommandFromQueue];
	
}

- (void) selectModule
{
	[self writeModuleSelect];
}

- (void) readAdcs
{
	@synchronized (self){
		int i;
		[self writeLcmEnable];
		[self writeModuleSelect];
		for(i=0;i<8;i++){
			[self writeReadADC:i];
		}
		[self writeShipCmd];
	}
}

- (void) writeGain
{
    if([serialPort isOpen]){
		if([self setAllGains]){
			char cmdData[5];
			cmdData[0] = kPacGainCmd;
			cmdData[1] = kPacGainWriteAll;
			cmdData[2] = 0x10 | ((gainValue & 0xf0)>>4);
			cmdData[3] = (gainValue & 0x0f)<<4;
			[self writeCmdData:[NSData dataWithBytes:cmdData length:4]];
		}
		else {
			char cmdData[5];
			cmdData[0] = kPacGainCmd;
			cmdData[1] = kPacGainWriteOneGain;
			cmdData[2] = gainChannel+1;
			cmdData[3] = 0x10 | ((gainValue & 0xf0)>>4);
			cmdData[4] = (gainValue & 0x0f)<<4;
			[self writeCmdData:[NSData dataWithBytes:cmdData length:5]];
		}
        
        [self readAllGains];
        
        if(setAllGains){
            int i;
            for(i=0;i<148;i++){
                [self setGain:i withValue:[self gainValue]];
            }
        }
    }
}

- (void) writeGain:(int)aChannel value:(int)aValue
{
    char cmdData[5];
    cmdData[0] = kPacGainCmd;
    cmdData[1] = kPacGainWriteOneGain;
    cmdData[2] = aChannel+1;
    cmdData[3] = 0x10 | ((aValue & 0xf0)>>4);
    cmdData[4] = (aValue & 0x0f)<<4;
    [self writeCmdData:[NSData dataWithBytes:cmdData length:5]];
}

- (void) readGain
{
	[self writeReadGain];
}

- (void) readAllGains
{
	[self writeReadAllGains];
}

#pragma mark •••Data Records
- (unsigned long) dataId { return dataId; }
- (void) setDataId: (unsigned long) DataId
{
    dataId = DataId;
}
- (void) setDataIds:(id)assigner
{
    dataId       = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherPac
{
    [self setDataId:[anotherPac dataId]];
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(id)userInfo
{
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"PacModel"];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
                                 @"ORPacDecoderForAdc",				@"decoder",
                                 [NSNumber numberWithLong:dataId],   @"dataId",
                                 [NSNumber numberWithBool:NO],       @"variable",
                                 [NSNumber numberWithLong:8],        @"length",
                                 nil];
    [dataDictionary setObject:aDictionary forKey:@"Adcs"];
    
    return dataDictionary;
}

- (void) dataReceived:(NSNotification*)note
{
	BOOL done = NO;
	if(!lastRequest)return;
	
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		if(!inComingData)inComingData = [[NSMutableData data] retain];
        [inComingData appendData:[[note userInfo] objectForKey:@"data"]];
		
		char* theCmd = (char*)[lastRequest bytes];
		switch (theCmd[0]){
			case kPacADCmd:
				if([inComingData length] >= 3) {
					unsigned char* theData	 = (unsigned char*)[inComingData bytes];
					short theChannel = theCmd[1] & 0x7;
					short msb		 = theData[0];
					short lsb		 = theData[1];
					if(theData[2] == kPacOkByte) {
                        if(theChannel==0){
                            if([self readingTemperatures])  [self setAdc:theChannel value: msb<<8 | lsb];
                            else [self setLcm: msb<<8 | lsb];
                        }
                        else [self setAdc:theChannel value: msb<<8 | lsb];
                    }
					else NSLogError(@"ADC !OK",@"PAC",nil);
					done = YES;
				}
                break;
				
			case kPacSelCmd:
				if([inComingData length] >= 1) {
					unsigned char* theData	 = (unsigned char*)[inComingData bytes];
					if(theData[0] != kPacOkByte)  NSLogError(@"Port D !OK",@"PAC",nil);
					done = YES;
				}
                break;
				
			case kPacGainCmd:
				if(theCmd[1] == kPacGainReadOneGain){
					if([inComingData length] >= 3) {
						unsigned char* theData	 = (unsigned char*)[inComingData bytes];
						short msb		 = (theData[0]&0xf)<<4;
						short lsb		 = (theData[1]&0xf0)>>4;
						if(theData[2] == kPacOkByte) NSLog(@"0x%x\n",msb | lsb);
						else NSLogError(@"DAC !OK",@"PAC",nil);
						done = YES;
					}
				}
				else if(theCmd[1] == kPacGainReadAll){
                    unsigned char* ptr	 = (unsigned char*)[inComingData bytes];
                    int i;
                    unsigned len = [inComingData length];
                    if(len >= 297) {
                        if(ptr[296] == kPacOkByte){
                            for(i=0;i<len-1;i+=2){
                                short msb		 = (ptr[i]&0xf)<<4;
                                short lsb		 = (ptr[i+1]&0xf0)>>4;
                                gainReadBack[147-i/2] = msb|lsb;
                            }
                            [self setGainReadBack:0 withValue:gainReadBack[0]]; //side effect -- force refresh
                            NSDate* theDate = [NSDate date];
                            [self setLastGainRead: theDate];
                            
                        }
                        else if(ptr[296]==kPacErrorByte){
                            NSLogError(@"DAC !OK",@"PAC",nil);
                        }
                        done = YES;
                    }
 				}
				else if(theCmd[1] == kPacGainWriteOneGain){
					if([inComingData length] >= 1) {
						unsigned char* theData	 = (unsigned char*)[inComingData bytes];
						if(theData[0] != kPacOkByte) NSLogError(@"DAC !OK",@"PAC",nil);
						done = YES;
					}
				}
				else if(theCmd[1] == kPacGainWriteAll){
					if([inComingData length] >= 1) {
						unsigned char* theData	 = (unsigned char*)[inComingData bytes];
						if(theData[0] != kPacOkByte) NSLogError(@"DAC !OK",@"PAC",nil);
						done = YES;
					}
				}
                break;
				
			case kPacLcmEnaCmd:
				if([inComingData length] >= 1) {
					unsigned char* theData	 = (unsigned char*)[inComingData bytes];
					if(theData[0] != kPacOkByte)  NSLogError(@"LCM ENA !OK",@"PAC",nil);
					done = YES;
				}
                break;
                
            default:
                done = YES;
                break;
		}
		
		if(done){
            [inComingData release];
            inComingData = nil;
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
			[self setLastRequest:nil];			 //clear the last request
			[self processOneCommandFromQueue];	 //do the next command in the queue
		}
	}
}

- (unsigned long) timeMeasured:(int)index
{
	if(index<0)return 0;
	else if(index>=8)return 0;
	else return timeMeasured[index];
}

- (void)serialPortWriteProgress:(NSDictionary *)dataDictionary
{
}

- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{
    NSMutableDictionary* objDictionary = [NSMutableDictionary dictionary];
    [objDictionary setObject:NSStringFromClass([self class]) forKey:@"Class Name"];
    if([lastGainFile length])[objDictionary setObject:lastGainFile forKey:@"RDAC File"];
    
	NSMutableArray* gainArray = [NSMutableArray array];
	int i;
	for(i=0;i<148;i++){
		[gainArray addObject:[NSNumber numberWithInt:gain[i]]];
	}
	
    [objDictionary setObject:gainArray forKey:@"gain"];
	
	[dictionary setObject:objDictionary forKey:[self identifier]];
    
	return objDictionary;
}

- (void) setPollingState:(NSTimeInterval)aState
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollingState:pollingState];
    
    pollingState = aState;
    
    [self performSelector:@selector(_startPolling) withObject:nil afterDelay:0.5];
    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelPollingStateChanged object: self];
}

- (NSTimeInterval)	pollingState
{
    return pollingState;
}

- (void) readGainFile:(NSString*) aPath
{
	[self setLastGainFile:aPath];
	NSString* contents = [NSString stringWithContentsOfFile:[aPath stringByExpandingTildeInPath] encoding:NSASCIIStringEncoding error:nil];
	contents = [contents stringByReplacingOccurrencesOfString:@"\r" withString:@"\n"];
	NSArray* lines = [contents componentsSeparatedByString:@"\n"];
	for(id aLine in lines){
		aLine = [aLine stringByReplacingOccurrencesOfString:@" " withString:@""];
		NSArray* parts = [aLine componentsSeparatedByString:@","];
		if([parts count] == 5){
			int index = [[parts objectAtIndex:0] intValue];
			if(index < 38){
				gain[index]			= [[parts objectAtIndex:1] intValue];
				gain[index+37]		= [[parts objectAtIndex:2] intValue];
				gain[index+2*37]	= [[parts objectAtIndex:3] intValue];
				gain[index+3*37]	= [[parts objectAtIndex:4] intValue];
			}
		}
	}
	[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelGainsChanged object:self];
}

- (void) saveGainFile:(NSString*) aPath
{
	NSString* fullFileName = [aPath stringByExpandingTildeInPath];
	int i;
	NSString* s = @"";
	for(i=0;i<37;i++){
		s = [s stringByAppendingFormat:@"%d,%d,%d,%d,%d\n",i,gain[i],gain[i+37],gain[i+2*37],gain[i+3*37]];
	}
	
	[s writeToFile:fullFileName atomically:NO encoding:NSASCIIStringEncoding error:nil];
    
}
#pragma mark •••Bit Processing Protocol
- (void) processIsStarting
{
	[self _stopPolling];
    readOnce = NO;
}

- (void) processIsStopping
{
	[self _startPolling];
}

//note that everything called by these routines MUST be threadsafe
- (void) startProcessCycle
{
	if(!readOnce){
		@try {
			if([cmdQueue count] == 0) {
				[self performSelectorOnMainThread:@selector(readAdcs) withObject:nil waitUntilDone:NO];
				readOnce = YES;
			}
		}
		@catch(NSException* localException) {
			//catch this here to prevent it from falling thru, but nothing to do.
		}
	}
}

- (void) endProcessCycle
{
    readOnce = NO;
}

- (NSString*) identifier
{
	NSString* s;
 	@synchronized(self){
		s= [NSString stringWithFormat:@"Pac,%lu",[self uniqueIdNumber]];
	}
	return s;
}

- (NSString*) processingTitle
{
	NSString* s;
 	@synchronized(self){
		s= [self identifier];
	}
	return s;
}

- (NSString*)adcName:(int)aChan
{
    switch (aChan){
        case 0: return @"Gen Temp";
        case 1: return @"Bias V.";
        case 2: return @"Free";
        case 3: return @"Free";
        case 4: return @"Free";
        case 5: return @"Free";
        case 6: return @"Carousel T1";
        case 7: return @"Carousel T2";
        default: return @"";
    }
}

- (NSString*)processName:(int)aChan
{
    switch (aChan){
        case 0: return @"Gen Temp";
        case 1: return @"Bias V.";
        case 2: return @"Carousel T1";
        case 3: return @"Carousel T2";
        case 4: return @"LCM";
        case 5: return @"Module";
        case 6: return @"PreAmp";
        case 7: return @"Adc Chan";
        default: return @"";
    }
}

- (double) convertedValue:(int)aChan
{
	double theValue;
	@synchronized(self){
        switch (aChan){
            case 0: theValue =  [self convertedAdc:0];  break;
            case 1: theValue =  [self convertedAdc:1];  break;
            case 2: theValue =  [self convertedAdc:6];  break;
            case 3: theValue =  [self convertedAdc:7];  break;
            case 4: theValue =  [self lcm];             break;
            case 5: theValue =  [self module];          break;
            case 6: theValue =  [self preAmp];          break;
            case 7: theValue =  [self adcChannel];      break;
            default:theValue = 0;                       break;
        }
	}
	return theValue;
}

- (double) maxValueForChan:(int)aChan
{
	double theValue;
	@synchronized(self){
        if(aChan>=0 && aChan<8) theValue = [[[processLimits objectAtIndex:aChan] objectForKey:@"HiLimit"]doubleValue];
		else         theValue = 100.0;
	}
	return theValue;
}

- (double) minValueForChan:(int)aChan
{
	double theValue;
	@synchronized(self){
        if(aChan>=0 && aChan<8) theValue = [[[processLimits objectAtIndex:aChan] objectForKey:@"LoLimit"]doubleValue];
		else         theValue = 100.0;
	}
	return theValue;
}

- (void) getAlarmRangeLow:(double*)theLoAlarm high:(double*)theHighAlarm channel:(int)aChan
{
	@synchronized(self){
        if([self convertedValue:aChan] == kBadPacValue){
            *theLoAlarm = -999;
            *theHighAlarm = 999999;
        }
        else if(aChan>=0 && aChan<8) {
            *theLoAlarm = [[[processLimits objectAtIndex:aChan] objectForKey:@"LoAlarm"]doubleValue];
            *theHighAlarm = [[[processLimits objectAtIndex:aChan] objectForKey:@"HiAlarm"]doubleValue];
        }
        else {
            *theHighAlarm = 100;
            *theLoAlarm = -.001;
        }
	}
}

- (BOOL) processValue:(int)channel
{
	BOOL r;
	@synchronized(self){
        if(channel==0)      return [self isConnected];
        else if(channel==1) return ![self lcmEnabled];
        else return NO;
    }
	return r;
}

- (void) setProcessOutput:(int)channel value:(int)value
{
    //nothing to do. not used in adcs. really shouldn't be in the protocol
}
- (void) setProcessLimitDefaults
{
    [processLimits release];
    processLimits = [[NSMutableArray array] retain];
    NSMutableDictionary* entry;
    //entry 0 Gen Temp
    entry = [NSMutableDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithFloat:-50],@"LoAlarm",
             [NSNumber numberWithFloat:100],@"HiAlarm",
             [NSNumber numberWithFloat:-30],@"LoLimit",
             [NSNumber numberWithFloat:70], @"HiLimit",
             nil];
    [processLimits addObject:entry];
    //entry 1 Bias V
    entry = [NSMutableDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithFloat:-50],@"LoAlarm",
             [NSNumber numberWithFloat:100],@"HiAlarm",
             [NSNumber numberWithFloat:-30],@"LoLimit",
             [NSNumber numberWithFloat:70], @"HiLimit",
             nil];
    [processLimits addObject:entry];
    //entry 2 PreAmp T
    entry = [NSMutableDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithFloat:-50],@"LoAlarm",
             [NSNumber numberWithFloat:100],@"HiAlarm",
             [NSNumber numberWithFloat:-30],@"LoLimit",
             [NSNumber numberWithFloat:70], @"HiLimit",
             nil];
    [processLimits addObject:entry];
    //entry 3 Carrousel T
    entry = [NSMutableDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithFloat:-50],@"LoAlarm",
             [NSNumber numberWithFloat:100],@"HiAlarm",
             [NSNumber numberWithFloat:-30],@"LoLimit",
             [NSNumber numberWithFloat:70], @"HiLimit",
             nil];
    [processLimits addObject:entry];
    //entry 4 LCM
    entry = [NSMutableDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithFloat:-1],@"LoAlarm",
             [NSNumber numberWithFloat:5],@"HiAlarm",
             [NSNumber numberWithFloat:0],@"LoLimit",
             [NSNumber numberWithFloat:5], @"HiLimit",
             nil];
    [processLimits addObject:entry];
    //entry 5 Module
    entry = [NSMutableDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithFloat:-1],@"LoAlarm",
             [NSNumber numberWithFloat:32],@"HiAlarm",
             [NSNumber numberWithFloat:0],@"LoLimit",
             [NSNumber numberWithFloat:31], @"HiLimit",
             nil];
    [processLimits addObject:entry];
    //entry 6 Preamp
    entry = [NSMutableDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithFloat:-1],@"LoAlarm",
             [NSNumber numberWithFloat:8],@"HiAlarm",
             [NSNumber numberWithFloat:0],@"LoLimit",
             [NSNumber numberWithFloat:7], @"HiLimit",
             nil];
    [processLimits addObject:entry];
    //entry 7 Adc Chan
    entry = [NSMutableDictionary dictionaryWithObjectsAndKeys:
             [NSNumber numberWithFloat:-1],@"LoAlarm",
             [NSNumber numberWithFloat:148],@"HiAlarm",
             [NSNumber numberWithFloat:0],@"LoLimit",
             [NSNumber numberWithFloat:147], @"HiLimit",
             nil];
    [processLimits addObject:entry];
}

- (BOOL) vetoInPlace
{
	return lcmEnabledAlarm!=nil;
}

@end

@implementation ORPacModel (private)
- (void) checkVetoCondition
{
    if(![self readingTemperatures] && [self isConnected]){
        [[ORGlobal sharedGlobal] addRunVeto:@"LCM Enabled" comment:@"Leakage Current Measurement Enabled in PAC Board"];
        NSLog(@"%@ put run veto in place for leakage current measurement.\n",[self fullID]);
        if(!lcmEnabledAlarm){
            lcmEnabledAlarm = [[ORAlarm alloc] initWithName:[NSString stringWithFormat:@"Leakage Current Measurement"] severity:kInformationAlarm];
            [lcmEnabledAlarm setSticky:YES];
            [lcmEnabledAlarm setHelpString:@"The PAC board posted this informational alarm because it is set to measure leakage current."];
        }
        [lcmEnabledAlarm setAcknowledged:NO];
        [lcmEnabledAlarm postAlarm];
    }
    else {
        [[ORGlobal sharedGlobal] removeRunVeto:@"LCM Enabled"];
        NSLog(@"%@ removed leakage current measurement veto.\n",[self fullID]);
        [lcmEnabledAlarm clearAlarm];
        [lcmEnabledAlarm release];
        lcmEnabledAlarm = nil;
    }
	[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelVetoChanged object:self];
}

- (void) shipAdcValues
{
    if([[ORGlobal sharedGlobal] runInProgress]){
		
		unsigned long data[18];
		data[0] = dataId | 18;
		data[1] = ([self uniqueIdNumber]&0xfff);
		
		int index = 2;
		int i;
		for(i=0;i<8;i++){
			data[index++] = timeMeasured[i];
			data[index++] = adc[i];
		}
		[[NSNotificationCenter defaultCenter] postNotificationName:ORQueueRecordForShippingNotification
															object:[NSData dataWithBytes:data length:sizeof(long)*18]];
	}
}
- (void) loadLogBuffer
{
	NSString*   outputString = nil;
	if(logToFile) {
		outputString = [NSString stringWithFormat:@"%lu ",timeMeasured[0]];
		short chan;
		for(chan=0;chan<8;chan++){
			outputString = [outputString stringByAppendingFormat:@"%.2f ",[self convertedAdc:chan]];
		}
		outputString = [outputString stringByAppendingString:@"\n"];
		//accumulate into a buffer, we'll write the file later
		if(!logBuffer)logBuffer = [[NSMutableArray arrayWithCapacity:1024] retain];
		if([outputString length]){
			[logBuffer addObject:outputString];
		}
	}
	readCount++;
}
- (void) timeout
{
	@synchronized (self){
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
		NSLogError(@"command timeout",@"PAC",nil);
		[self setLastRequest:nil];
		[cmdQueue removeAllObjects]; //if we timeout we just flush the queue
		[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelQueCountChanged object: self];
		//[self processOneCommandFromQueue];	 //do the next command in the queue
		gainIndex = 0;
	}
}

- (void) processOneCommandFromQueue
{
	if([cmdQueue count] > 0){
		NSData* cmdData = [cmdQueue dequeue];
		[[NSNotificationCenter defaultCenter] postNotificationName:ORPacModelQueCountChanged object: self];
		unsigned char* cmd = (unsigned char*)[cmdData bytes];
		if(cmd[0] == kPacShipAdcs){
			[self setLastRequest:nil];
			[self shipAdcValues];
			[self loadLogBuffer];
			[self processOneCommandFromQueue];
		}
		else {
			[self setLastRequest:cmdData];
			[serialPort writeDataInBackground:cmdData];
			[self performSelector:@selector(timeout) withObject:nil afterDelay:1];
		}
	}
}

- (void) _stopPolling
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(_pollAllChannels) object:nil];
	pollRunning = NO;
}

- (void) _startPolling
{
	[self _setUpPolling:YES];
}

- (void) _setUpPolling:(BOOL)verbose
{
    if(pollingState!=0){
		readCount = 0;
		pollRunning = YES;
        if(verbose)NSLog(@"Polling PAC,%d  every %.0f seconds.\n",[self uniqueIdNumber],pollingState);
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(_pollAllChannels) object:nil];
        [self _pollAllChannels];
    }
    else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(_pollAllChannels) object:nil];
        if(verbose)NSLog(@"Not Polling PAC,%d\n",[self uniqueIdNumber]);
    }
}

- (void) _pollAllChannels
{
	float nextTry = pollingState;
    @try {
		if([cmdQueue count] == 0)[self readAdcs];
		else nextTry = .5;
    }
	@catch(NSException* localException) {
		//catch this here to prevent it from falling thru, but nothing to do.
	}
	
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(_pollAllChannels) object:nil];
	if(pollingState!=0){
		[self performSelector:@selector(_pollAllChannels) withObject:nil afterDelay:nextTry];
	}
}

@end