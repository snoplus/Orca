//--------------------------------------------------------
// ORMks651cModel
// Created by David G. Phillips II on Tue Aug 30, 2011
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORMks651cModel.h"
#import "ORSerialPort.h"
#import "ORSerialPortList.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"
#import "ORTimeRate.h"
#import "ORSafeQueue.h"

#pragma mark •••External Strings
NSString* ORMks651cModelSpanCalibrationChanged = @"ORMks651cModelSpanCalibrationChanged";
NSString* ORMks651cModelSpecialZeroChanged = @"ORMks651cModelSpecialZeroChanged";
NSString* ORMks651cModelSetPtSelectionChanged = @"ORMks651cModelSetPtSelectionChanged";
NSString* ORMks651cLowThresholdChanged		= @"ORMks651cLowThresholdChanged";
NSString* ORMks651cHighThresholdChanged		= @"ORMks651cHighThresholdChanged";
NSString* ORMks651cOpenSoftstartChanged		= @"ORMks651cOpenSoftstartChanged";
NSString* ORMks651cCloseSoftstartChanged	= @"ORMks651cCloseSoftstartChanged";
NSString* ORMks651cAnalogSoftstartChanged	= @"ORMks651cAnalogSoftstartChanged";
NSString* ORMks651cAnalogSetPointChanged	= @"ORMks651cAnalogSetPointChanged";
NSString* ORMks651cAnalogFSLevelChanged		= @"ORMks651cAnalogFSLevelChanged";
NSString* ORMks651cLearningChanged			= @"ORMks651cLearningChanged";
NSString* ORMks651cLocalChanged				= @"ORMks651cLocalChanged";
NSString* ORMks651cUnitsChanged				= @"ORMks651cUnitsChanged";
NSString* ORMks651cPressureScaleChanged		= @"ORMks651cPressureScaleChanged";
NSString* ORMks651cShipPressuresChanged		= @"ORMks651cShipPressuresChanged";
NSString* ORMks651cPollTimeChanged			= @"ORMks651cPollTimeChanged";
NSString* ORMks651cSerialPortChanged		= @"ORMks651cSerialPortChanged";
NSString* ORMks651cPortNameChanged			= @"ORMks651cPortNameChanged";
NSString* ORMks651cPortStateChanged			= @"ORMks651cPortStateChanged";
NSString* ORMks651cPressureChanged			= @"ORMks651cPressureChanged";
NSString* ORMks651cSetPointChanged          = @"ORMks651cSetPointChanged";
NSString* ORMks651cSoftstartRateChanged     = @"ORMks651cSoftstartRateChanged";
NSString* ORMks651cValveTypeChanged         = @"ORMks651cValveTypeChanged";
NSString* ORMks651cAnalogRangeChanged       = @"ORMks651cAnalogRangeChanged";
NSString* ORMks651cSetPointTypeChanged      = @"ORMks651cSetPointTypeChanged";
NSString* ORMks651cPositionRangeChanged     = @"ORMks651cPositionRangeChanged";
NSString* ORMks651cControlDirectionChanged  = @"ORMks651cControlDirectionChanged";
NSString* ORMks651cSensorRangeChanged       = @"ORMks651cSensorRangeChanged";
NSString* ORMks651cSensorVoltageRangeChanged= @"ORMks651cSensorVoltageRangeChanged";
NSString* ORMks651cSensorTypeChanged        = @"ORMks651cSensorTypeChanged";
NSString* ORMks651cSystemStatusChanged      = @"ORMks651cSystemStatusChanged";
NSString* ORMks651cSoftwareVersionChanged   = @"ORMks651cSoftwareVersionChanged";
NSString* ORMks651cBatteryStatusChanged     = @"ORMks651cBatteryStatusChanged";
NSString* ORMks651cValveResponseChanged     = @"ORMks651cValveResponseChanged";
NSString* ORMks651cLeadValueChanged         = @"ORMks651cLeadValueChanged";
NSString* ORMks651cGainValueChanged         = @"ORMks651cGainValueChanged";
NSString* ORMks651cControlTypeChanged		= @"ORMks651cControlTypeChanged";
NSString* ORMks651cChecksumChanged          = @"ORMks651cChecksumChanged";

NSString* ORMks651cLock = @"ORMks651cLock";

@interface ORMks651cModel (private)
- (void) runStarted:(NSNotification*)aNote;
- (void) runStopped:(NSNotification*)aNote;
- (void) timeout;
- (void) processOneCommandFromQueue;
- (void) process_response:(NSString*)theResponse;
- (BOOL) decodeValveResponseToPowerFail:(NSString*)theResponse;
- (BOOL) decodeControlType:(NSString*)theResponse;
- (BOOL) decodeGainValue:(NSString*)theResponse;
- (BOOL) decodeLeadValue:(NSString*)theResponse;
- (BOOL) decodeSetPoint:(NSString*)theResponse;
- (BOOL) decodeSystemPressure:(NSString*)theResponse;
- (BOOL) decodeAlternateSystemStatus:(NSString*)theResponse;
- (BOOL) decodeThresholdLimits:(NSString*)theResponse;
- (BOOL) decodeSoftStartRate:(NSString*)theResponse;
- (BOOL) decodeValveType:(NSString*)theResponse;
- (BOOL) decodeSetPointType:(NSString*)theResponse;
- (BOOL) decodePositionIndicatorRange:(NSString*)theResponse;
- (BOOL) decodeDirectReverse:(NSString*)theResponse;
- (BOOL) decodeSensorRange:(NSString*)theResponse;
- (BOOL) decodePressureUnits:(NSString*)theResponse;
- (BOOL) decodeSensorVoltageRange:(NSString*)theResponse;
- (BOOL) decodeSensorType:(NSString*)theResponse;
- (BOOL) decodeSystemStatus:(NSString*)theResponse;
- (BOOL) decodeSoftwareVersion:(NSString*)theResponse;
- (BOOL) decodeBatteryStatus:(NSString*)theResponse;
- (BOOL) decodeAnalogSetPoint:(NSString*)theResponse;
- (BOOL) decodeAnalogRange:(NSString*)theResponse;
- (BOOL) decodeAnalogSoftStart:(NSString*)theResponse;
- (BOOL) decodeOpenSoftStart:(NSString*)theResponse;
- (BOOL) decodeCloseSoftStart:(NSString*)theResponse;
- (float) limitFloatValue:(float)aValue min:(float)aMin max:(float)aMax;
@end

@implementation ORMks651cModel
- (id) init
{
	self = [super init];
    [self registerNotificationObservers];
	return self;
}


- (void) dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [buffer release];
	[cmdQueue release];
	[lastRequest release];
    [portName release];
    if([serialPort isOpen]){
        [serialPort close];
    }
    [serialPort release];
	[timeRates release];

	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"Mks651c.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORMks651cController"];
}

- (NSString*) helpURL
{
	return @"RS232/MKS_651c.html";
}

- (void) registerNotificationObservers
{
	NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];

    [notifyCenter addObserver : self
                     selector : @selector(dataReceived:)
                         name : ORSerialPortDataReceived
                       object : nil];

    [notifyCenter addObserver: self
                     selector: @selector(runStarted:)
                         name: ORRunStartedNotification
                       object: nil];
    
    [notifyCenter addObserver: self
                     selector: @selector(runStopped:)
                         name: ORRunStoppedNotification
                       object: nil];

}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
        NSString* theString = [[[[NSString alloc] initWithData:[[note userInfo] objectForKey:@"data"] 
												      encoding:NSASCIIStringEncoding] autorelease] uppercaseString];

		//the serial port may break the data up into small chunks, so we have to accumulate the chunks until
		//we get a full piece.
        theString = [[theString componentsSeparatedByString:@"\n"] componentsJoinedByString:@""];
        if(!buffer)buffer = [[NSMutableString string] retain];
        [buffer appendString:theString];					
		
        do {
            NSRange lineRange = [buffer rangeOfString:@"\r"];
            if(lineRange.location!= NSNotFound){
                NSMutableString* theResponse = [[[buffer substringToIndex:lineRange.location+1] mutableCopy] autorelease];
                [buffer deleteCharactersInRange:NSMakeRange(0,lineRange.location+1)];      //take the cmd out of the buffer
				
				[self process_response:theResponse];
    
				[self setLastRequest:nil];			 //clear the last request
				[self processOneCommandFromQueue];	 //do the next command in the queue
            }
        } while([buffer rangeOfString:@"\r\n"].location!= NSNotFound);
	}
}


- (void) shipPressureValues
{
    if([[ORGlobal sharedGlobal] runInProgress]){
		
		uint32_t data[4];
		data[0] = dataId | 4;
		data[1] = ([self units]<<16) | ([self uniqueIdNumber]&0xfff);
		
		union {
			float asFloat;
			uint32_t asLong;
		}theData;
		
		theData.asFloat = pressure;
		data[2] = theData.asLong;			
		data[3] = timeMeasured;
		
		[[NSNotificationCenter defaultCenter] postNotificationName:ORQueueRecordForShippingNotification 
															object:[NSData dataWithBytes:data length:sizeof(int32_t)*4]];
	}
}


#pragma mark •••Accessors

- (float) spanCalibration
{
    return spanCalibration;
}

- (void) setSpanCalibration:(float)aSpanCalibration
{
    [[[self undoManager] prepareWithInvocationTarget:self] setSpanCalibration:spanCalibration];
    
    spanCalibration = aSpanCalibration;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cModelSpanCalibrationChanged object:self];
}

- (float) specialZero
{
    return specialZero;
}

- (void) setSpecialZero:(float)aSpecialZero
{
    [[[self undoManager] prepareWithInvocationTarget:self] setSpecialZero:specialZero];
    
    specialZero = aSpecialZero;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cModelSpecialZeroChanged object:self];
}

- (int) setPtSelection
{
    return setPtSelection;
}

- (void) setSetPtSelection:(int)aSetPtSelection
{
    [[[self undoManager] prepareWithInvocationTarget:self] setSetPtSelection:setPtSelection];
    setPtSelection = aSetPtSelection;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cModelSetPtSelectionChanged object:self];
}

- (float) openSoftstart
{
    return openSoftstart;
}

- (void) setOpenSoftstart:(float)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setOpenSoftstart:openSoftstart];
    openSoftstart = [self limitFloatValue:aValue min:.1 max:100];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cOpenSoftstartChanged object:self];
}

- (float) closeSoftstart
{
    return closeSoftstart;
}

- (void) setCloseSoftstart:(float)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setCloseSoftstart:closeSoftstart];
    closeSoftstart = [self limitFloatValue:aValue min:.1 max:100];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cCloseSoftstartChanged object:self];
}

- (float) analogSoftstart
{
    return analogSoftstart;
}

- (void) setAnalogSoftstart:(float)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAnalogSoftstart:analogSoftstart];
	analogSoftstart = [self limitFloatValue:aValue min:.1 max:100];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cAnalogSoftstartChanged object:self];
}

- (float) analogSetPoint
{
    return analogSetPoint;
}

- (void) setAnalogSetPoint:(float)aAnalogSetPoint
{    
    analogSetPoint = aAnalogSetPoint;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cAnalogSetPointChanged object:self];
}

- (int) analogFSLevel
{
    return analogFSLevel;
}

- (void) setAnalogFSLevel:(int)aAnalogFSLevel
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAnalogFSLevel:analogFSLevel];
    analogFSLevel = aAnalogFSLevel;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cAnalogFSLevelChanged object:self];
}

- (int) learning
{
    return learning;
}

- (void) setLearning:(int)aLearning
{
    learning = aLearning;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cLearningChanged object:self];
}

- (BOOL) local
{
    return local;
}

- (void) setLocal:(BOOL)aLocal
{
    local = aLocal;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cLocalChanged object:self];
}

- (NSString*) unitsString;
{
    switch(units){
        case 0: return @"(Torr)";
        case 1: return @"(mTorr)";
        case 2: return @"(mBar)";
        case 3: return @"(uBar)";
        case 4: return @"(kPa)";
        case 5: return @"(Pa)";
        case 6: return @"(cmH2O)";
        case 7: return @"(inH2O)";    
        default: return @"?";
    }
}

- (int) units
{
	return units;
}

- (void) setUnits:(int)aUnits
{
    if(aUnits<0) aUnits=0;
    else if(aUnits>7) aUnits=7;
    [[[self undoManager] prepareWithInvocationTarget:self] setUnits:units];
    units=aUnits;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cUnitsChanged object:self];
}

- (float) pressureScaleValue
{
	return pressureScaleValue;
}

- (int) pressureScale
{
   return pressureScale;
}

- (void) setPressureScale:(int)aPressureScale
{
	if(aPressureScale<0)aPressureScale=0;
	else if(aPressureScale>11)aPressureScale=11;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setPressureScale:pressureScale];
    
    pressureScale = aPressureScale;
	
	pressureScaleValue = powf(10.,(float)pressureScale);
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cPressureScaleChanged object:self];
}

- (ORTimeRate*)timeRate
{
	return timeRates;
}

- (BOOL) shipPressures
{
    return shipPressures;
}

- (void) setShipPressures:(BOOL)aShipPressures
{
    [[[self undoManager] prepareWithInvocationTarget:self] setShipPressures:shipPressures];
    shipPressures = aShipPressures;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cShipPressuresChanged object:self];
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cPollTimeChanged object:self];

	if(pollTime){
		[self performSelector:@selector(pollHardware) withObject:nil afterDelay:2];
	}
	else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	}
}

- (float) highThreshold:(int)index
{
    if(index>=0 && index<8)return highThreshold[index];
	else return 0.0;
} 

- (float) lowThreshold:(int)index
{
    if(index>=0 && index<8)return lowThreshold[index];
	else return 0.0;
} 



- (float) pressure
{
	return pressure;
}

- (float) setPoint:(int)index
{
    if(index>=0 && index<5)return setPoint[index];
	else return 0.0;
}

- (float) softstartRate:(int)index
{
    if(index>=0 && index<8)return softstartRate[index];
	else return 0.0;
} 

- (int) valveType
{
	return valveType;
}

- (int) analogRange
{
	return analogRange;
}

- (int) setPointType:(int)index
{
    if(index>=0 && index<6)return setPointType[index];
	else return 0;
}

- (BOOL) positionRange
{
	return positionRange;
}

- (BOOL) controlDirection
{
	return controlDirection;
}

- (int) sensorVoltageRange
{
	return sensorVoltageRange;
}

- (int) sensorType
{
	return sensorType;
}

- (float) systemStatus
{
	return systemStatus;
}

- (float) softwareVersion
{
	return softwareVersion;
}

- (int) batteryStatus
{
	return batteryStatus;
}

- (int) valveResponse
{
	return valveResponse;
}

- (float) leadValue:(int)index
{
    if(index>=0 && index<5)return leadValue[index];
	else return 0.0;
}

- (float) gainValue:(int)index
{
    if(index>=0 && index<5)return gainValue[index];
	else return 0.0;
}

- (int) controlType
{
	return controlType;
}

- (float) checksum
{
	return checksum;
}

- (uint32_t) timeMeasured
{
	return timeMeasured;
}

- (void) setPressure:(float)aValue
{
	pressure = aValue;
	//get the time(UT!)
	time_t	ut_Time;
	time(&ut_Time);
	//struct tm* theTimeGMTAsStruct = gmtime(&theTime);
	timeMeasured = (uint32_t)ut_Time;


	if(timeRates == nil) timeRates = [[ORTimeRate alloc] init];
	[timeRates addDataToTimeAverage:aValue];
	
	[[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cPressureChanged 
														object:self];
}


- (int) sensorRange
{
	return sensorRange;
}

- (void) setSensorRange:(int)aValue
{
 	[[[self undoManager] prepareWithInvocationTarget:self] setSensorRange:sensorRange];
    sensorRange = aValue;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSensorRangeChanged object:self];
}

- (void) setSetPoint:(int)index withValue:(float)aValue;
{
    if(index>=0 && index<5){
		[[[self undoManager] prepareWithInvocationTarget:self] setSetPoint:index withValue:setPoint[index]];
		setPoint[index] = aValue;
        [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSetPointChanged object:self];
        
	}
}

- (void) setLeadValue:(int)index withValue:(float)aValue;
{
    if(index>=0 && index<5){
		[[[self undoManager] prepareWithInvocationTarget:self] setLeadValue:index withValue:leadValue[index]];
        leadValue[index] = aValue;
        [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cLeadValueChanged object:self];
    }
}

- (void) setGainValue:(int)index withValue:(float)aValue;
{
    if(index>=0 && index<5){
		[[[self undoManager] prepareWithInvocationTarget:self] setGainValue:index withValue:gainValue[index]];
        gainValue[index] = aValue;        
        [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cGainValueChanged object:self];
	}
}

- (void) setAnalogRange:(int)aValue
{
	[[[self undoManager] prepareWithInvocationTarget:self] setAnalogRange:analogRange];
    analogRange = aValue;    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cAnalogRangeChanged object:self];
}


- (void) setSetPointType:(int)index withValue:(int)aValue;
{
    if(index>=0 && index<5){
		[[[self undoManager] prepareWithInvocationTarget:self] setSetPointType:index withValue:setPointType[index]];
        setPointType[index] = aValue;
        [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSetPointTypeChanged object:self];
    }
}

- (void) setLowThreshold:(int)index withValue:(float)aValue;
{
    if(index>=0 && index<2){
		[[[self undoManager] prepareWithInvocationTarget:self] setLowThreshold:index withValue:lowThreshold[index]];
        lowThreshold[index] = [self limitFloatValue:aValue min:.1 max:100];
        [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cLowThresholdChanged object:self];
    }
}

- (void) setHighThreshold:(int)index withValue:(float)aValue;
{
    if(index>=0 && index<2){
  		[[[self undoManager] prepareWithInvocationTarget:self] setHighThreshold:index withValue:highThreshold[index]];
		highThreshold[index] = [self limitFloatValue:aValue min:.1 max:100];
        [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cHighThresholdChanged object:self];
    }
}

- (void) setSoftstartRate:(int)index withValue:(float)aValue;
{
    if(index>=0 && index<5){
        softstartRate[index] = [self limitFloatValue:aValue min:.1 max:100];
        [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSoftstartRateChanged object:self];
    }
}

- (void) setValveResponse:(int)aValue
{
	[[[self undoManager] prepareWithInvocationTarget:self] setValveResponse:valveResponse];
    valveResponse = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cValveResponseChanged object:self];
}

- (void) setValveType:(int)aValue
{
 	[[[self undoManager] prepareWithInvocationTarget:self] setValveType:valveType];
    valveType = [self limitFloatValue:aValue min:0 max:2];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cValveTypeChanged object:self];
}

- (void) setPositionRange:(BOOL)aValue
{
 	[[[self undoManager] prepareWithInvocationTarget:self] setPositionRange:positionRange];
    positionRange = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cPositionRangeChanged object:self];
}

- (void) setControlDirection:(BOOL)aValue
{
 	[[[self undoManager] prepareWithInvocationTarget:self] setControlDirection:controlDirection];
    controlDirection = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cControlDirectionChanged  object:self];
}

- (void) setSensorVoltageRange:(int)aValue
{
 	[[[self undoManager] prepareWithInvocationTarget:self] setSensorVoltageRange:sensorVoltageRange];
    sensorVoltageRange = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSensorVoltageRangeChanged object:self];
}

- (void) setSensorType:(int)aValue
{
 	[[[self undoManager] prepareWithInvocationTarget:self] setSensorType:sensorType];
    sensorType = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSensorTypeChanged object:self];
}

- (void) setSystemStatus:(float)aValue
{
    systemStatus = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSystemStatusChanged object:self];
}

- (void) setSoftwareVersion:(float)aValue
{
    softwareVersion = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSoftwareVersionChanged 
                                                        object:self];
}

- (void) setBatteryStatus:(int)aValue
{
    batteryStatus = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cBatteryStatusChanged object:self];
}

- (void) setControlType:(int)aValue
{
 	[[[self undoManager] prepareWithInvocationTarget:self] setControlType:controlType];
    controlType = aValue;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cControlTypeChanged object:self];    
}

- (void) setChecksum:(float)aValue
{
    checksum = aValue;
    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cControlTypeChanged object:self];
}

- (NSString*) lastRequest
{
	return lastRequest;
}

- (void) setLastRequest:(NSString*)aRequest
{
	[lastRequest autorelease];
	lastRequest = [aRequest copy];    
}

- (BOOL) portWasOpen
{
    return portWasOpen;
}

- (void) setPortWasOpen:(BOOL)aPortWasOpen
{
    portWasOpen = aPortWasOpen;
}

- (NSString*) portName
{
    return portName;
}

- (void) setPortName:(NSString*)aPortName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];    

        BOOL valid = NO;
        NSEnumerator *enumerator = [ORSerialPortList portEnumerator];
        ORSerialPort *aPort;
        while (aPort = [enumerator nextObject]) {
            if([portName isEqualToString:[aPort name]]){
                [self setSerialPort:aPort];
                if(portWasOpen){
                    [self openPort:YES];
                 }
                valid = YES;
                break;
            }
        } 
        if(!valid){
            [self setSerialPort:nil];
        }       
    }

    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cPortNameChanged object:self];
}

- (ORSerialPort*) serialPort
{
    return serialPort;
}

- (void) setSerialPort:(ORSerialPort*)aSerialPort
{
    [aSerialPort retain];
    [serialPort release];
    serialPort = aSerialPort;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cSerialPortChanged object:self];
}

- (void) openPort:(BOOL)state
{
    if(state) {
        [serialPort open];
		[serialPort setSpeed:9600];
		[serialPort setParityNone];
		[serialPort setStopBits2:1];
		[serialPort setDataBits:8];
		[serialPort commitChanges];
   }
    else      [serialPort close];
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORMks651cPortStateChanged object:self];
}


#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setSpanCalibration:[decoder decodeFloatForKey:@"spanCalibration"]];
	[self setSpecialZero:[decoder decodeFloatForKey:@"specialZero"]];
	[self setSetPtSelection:[decoder decodeIntForKey:@"setPtSelection"]];
	[self setPositionRange:		[decoder decodeBoolForKey:	@"positionRange"]];
	[self setOpenSoftstart:		[decoder decodeFloatForKey:	 @"openSoftstart"]];
	[self setCloseSoftstart:	[decoder decodeFloatForKey:	 @"closeSoftstart"]];
	[self setAnalogSoftstart:	[decoder decodeFloatForKey:	 @"analogSoftstart"]];
	[self setAnalogSetPoint:	[decoder decodeFloatForKey:	 @"analogSetPoint"]];
	[self setAnalogRange:		[decoder decodeIntForKey:	 @"analogRange"]];
	[self setSensorRange:		[decoder decodeIntForKey:	 @"sensorRange"]];
	[self setSensorVoltageRange:[decoder decodeIntForKey:	 @"sensorVoltageRange"]];
	[self setAnalogFSLevel:		[decoder decodeIntForKey:	 @"analogFSLevel"]];
	[self setUnits:				[decoder decodeIntForKey:    @"units"]];
	[self setShipPressures:		[decoder decodeBoolForKey:	 @"shipPressures"]];
	[self setPollTime:			[decoder decodeIntForKey:	 @"pollTime"]];
	[self setPortWasOpen:		[decoder decodeBoolForKey:	 @"portWasOpen"]];
    [self setPortName:			[decoder decodeObjectForKey: @"portName"]];
	[self setPressureScale:		[decoder decodeIntForKey:    @"pressureScale"]];
    [self setValveResponse:		[decoder decodeIntForKey:    @"valveResponse"]];
    [self setSensorType:		[decoder decodeIntForKey:    @"sensorType"]];
    [self setControlType:		[decoder decodeIntForKey:    @"controlType"]];
    [self setValveType:			[decoder decodeIntForKey:    @"valveType"]];
	
	int i;
	for(i=0;i<5;i++){
		[self setSetPoint:i      withValue:	[decoder decodeFloatForKey: [NSString stringWithFormat:@"setPoint%d",i]]];
		[self setLeadValue:i     withValue:	[decoder decodeFloatForKey: [NSString stringWithFormat:@"leadValue%d",i]]];
		[self setGainValue:i     withValue:	[decoder decodeFloatForKey: [NSString stringWithFormat:@"gainValue%d",i]]];
		[self setSetPointType:i  withValue:	[decoder decodeIntForKey: [NSString stringWithFormat:@"setPointType%d",i]]];
		[self setSoftstartRate:i withValue:	[decoder decodeFloatForKey: [NSString stringWithFormat:@"softstartRate%d",i]]];
	}
	
	for(i=0;i<2;i++){
		[self setLowThreshold:i withValue:	[decoder decodeFloatForKey: [NSString stringWithFormat:@"lowThreshold%d",i]]];
		[self setHighThreshold:i withValue:	[decoder decodeFloatForKey: [NSString stringWithFormat:@"highThreshold%d",i]]];
	}
	
	[[self undoManager] enableUndoRegistration];
	timeRates = [[ORTimeRate alloc] init];
    [self registerNotificationObservers];

	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeFloat:spanCalibration	forKey:@"spanCalibration"];
    [encoder encodeFloat:specialZero		forKey:@"specialZero"];
    [encoder encodeInteger:setPtSelection		forKey:@"setPtSelection"];
    [encoder encodeBool:positionRange		forKey:@"positionRange"];
    [encoder encodeFloat:openSoftstart		forKey:@"openSoftstart"];
    [encoder encodeFloat:closeSoftstart		forKey:@"closeSoftstart"];
    [encoder encodeFloat:analogSoftstart	forKey:@"analogSoftstart"];
    [encoder encodeFloat:analogSetPoint		forKey:@"analogSetPoint"];
    [encoder encodeInteger:sensorRange			forKey:@"sensorRange"];
    [encoder encodeInteger:sensorVoltageRange	forKey:@"sensorVoltageRange"];
    [encoder encodeInteger:analogRange			forKey:@"analogRange"];
    [encoder encodeInteger:analogFSLevel		forKey:@"analogFSLevel"];
    [encoder encodeInteger:units				forKey: @"units"];
    [encoder encodeBool:shipPressures		forKey: @"shipPressures"];
    [encoder encodeInteger: pollTime			forKey: @"pollTime"];
    [encoder encodeBool:portWasOpen			forKey: @"portWasOpen"];
    [encoder encodeObject:portName			forKey: @"portName"];
	[encoder encodeInteger:pressureScale		forKey: @"pressureScale"];
	[encoder encodeInteger:valveResponse		forKey: @"valveResponse"];
	[encoder encodeInteger:sensorType			forKey: @"sensorType"];
	[encoder encodeInteger:controlType			forKey: @"controlType"];
	[encoder encodeInteger:valveType			forKey: @"valveType"];
	int i;
	for(i=0;i<5;i++){
		[encoder encodeFloat:setPoint[i]	  forKey: [NSString stringWithFormat:@"setPoint%d",i]];
		[encoder encodeFloat:leadValue[i]	  forKey: [NSString stringWithFormat:@"leadValue%d",i]];
		[encoder encodeFloat:gainValue[i]	  forKey: [NSString stringWithFormat:@"gainValue%d",i]];
		[encoder encodeFloat:softstartRate[i] forKey: [NSString stringWithFormat:@"softstartRate%d",i]];
		[encoder encodeInt:setPointType[i]	  forKey: [NSString stringWithFormat:@"setPointType%d",i]];
	}
	for(i=0;i<2;i++){
		[encoder encodeFloat:lowThreshold[i]  forKey: [NSString stringWithFormat:@"lowThreshold%d",i]];
		[encoder encodeFloat:highThreshold[i] forKey: [NSString stringWithFormat:@"highThreshold%d",i]];
	}
}

#pragma mark ••• Commands
- (void) addCmdToQueue:(NSString*)aCmd waitForResponse:(BOOL)waitForResponse
{
    if([serialPort isOpen]){ 
		if(!cmdQueue)cmdQueue = [[ORSafeQueue alloc] init];
		ORMks651cCmd* cmdObj  = [[[ORMks651cCmd alloc] init] autorelease];
		cmdObj.cmd = aCmd;
		cmdObj.waitForResponse = waitForResponse;
		
		[cmdQueue enqueue:cmdObj];
		if(!lastRequest){
			[self processOneCommandFromQueue];
		}
	}
}

- (void) readPressures
{
	[self addCmdToQueue:@"R5" waitForResponse:YES];
	[self addCmdToQueue:@"++ShipRecords" waitForResponse:NO];
}

- (void) readSetPoints
{
    [self addCmdToQueue:@"R0" waitForResponse:YES];
    [self addCmdToQueue:@"R1" waitForResponse:YES];
	[self addCmdToQueue:@"R2" waitForResponse:YES];
    [self addCmdToQueue:@"R3" waitForResponse:YES];
    [self addCmdToQueue:@"R4" waitForResponse:YES];
    [self addCmdToQueue:@"R10" waitForResponse:YES];
}



- (void) readThresholds
{
	[self addCmdToQueue:@"R11" waitForResponse:YES];
    [self addCmdToQueue:@"R12" waitForResponse:YES];
    [self addCmdToQueue:@"R13" waitForResponse:YES];
    [self addCmdToQueue:@"R14" waitForResponse:YES];
}

- (void) readSoftstartRates
{
	[self addCmdToQueue:@"R15" waitForResponse:YES];
	[self addCmdToQueue:@"R16" waitForResponse:YES];
    [self addCmdToQueue:@"R17" waitForResponse:YES];
    [self addCmdToQueue:@"R18" waitForResponse:YES];
    [self addCmdToQueue:@"R19" waitForResponse:YES];
	
    [self addCmdToQueue:@"R20" waitForResponse:YES];
    [self addCmdToQueue:@"R21" waitForResponse:YES];
    [self addCmdToQueue:@"R22" waitForResponse:YES];
}

- (void) readValveType		{ [self addCmdToQueue:@"R23" waitForResponse:YES]; } 
- (void) readAnalogRange	{ [self addCmdToQueue:@"R24" waitForResponse:YES]; }

- (void) readSetPointTypes
{
	[self addCmdToQueue:@"R25" waitForResponse:YES];
	[self addCmdToQueue:@"R26" waitForResponse:YES];
    [self addCmdToQueue:@"R27" waitForResponse:YES];
    [self addCmdToQueue:@"R28" waitForResponse:YES];
    [self addCmdToQueue:@"R29" waitForResponse:YES];
    [self addCmdToQueue:@"R30" waitForResponse:YES];
}

- (void) readPositionRange		{ [self addCmdToQueue:@"R31" waitForResponse:YES]; }
- (void) readControlDirection	{ [self addCmdToQueue:@"R32" waitForResponse:YES]; }
- (void) readSensorRange		{ [self addCmdToQueue:@"R33" waitForResponse:YES]; }
- (void) readUnits				{ [self addCmdToQueue:@"R34" waitForResponse:YES]; }
- (void) readSensorVoltageRange	{ [self addCmdToQueue:@"R35" waitForResponse:YES]; }
- (void) readSensorType			{ [self addCmdToQueue:@"R36" waitForResponse:YES]; }
- (void) readSystemStatus		{ [self addCmdToQueue:@"R37" waitForResponse:YES]; }
- (void) readSoftwareVersion	{ [self addCmdToQueue:@"R38" waitForResponse:YES]; }
- (void) readBatteryStatus		{ [self addCmdToQueue:@"R39" waitForResponse:YES]; }
- (void) readValveResponse		{ [self addCmdToQueue:@"R40" waitForResponse:YES]; }

- (void) readLeadValues
{
	[self addCmdToQueue:@"R41" waitForResponse:YES];
	[self addCmdToQueue:@"R42" waitForResponse:YES];
    [self addCmdToQueue:@"R43" waitForResponse:YES];
    [self addCmdToQueue:@"R44" waitForResponse:YES];
    [self addCmdToQueue:@"R45" waitForResponse:YES];
}

- (void) readGainValues
{
	[self addCmdToQueue:@"R46" waitForResponse:YES];
	[self addCmdToQueue:@"R47" waitForResponse:YES];
    [self addCmdToQueue:@"R48" waitForResponse:YES];
    [self addCmdToQueue:@"R49" waitForResponse:YES];
    [self addCmdToQueue:@"R50" waitForResponse:YES];
}

- (void) readControlType		{ [self addCmdToQueue:@"R51" waitForResponse:YES]; }
- (void) readChecksum			{ [self addCmdToQueue:@"R52" waitForResponse:YES]; }

- (void) initHardware
{
	[self writeSetPtSelection];
	[self writeAnalogRange];
	[self writeSetPoints];
	[self writeGainValues];
	[self writeLeadValues];
	[self writeSensorRange];	
	[self writeSensorVoltageRange];	
	[self writeUnits];	
	[self writeSetPointTypes];	
	[self writeValveResponse];	
	[self writeControlType];	
	[self writeSoftStartRates];	
	[self writeValveType];
	[self writeThresholds];
	[self writePositionRange];
	[self writeControlDirection];
}

- (void) readAndCompare
{
	[self readSetPoints];
	[self readGainValues];
	[self readLeadValues];
	[self readAnalogRange];
	[self readSensorRange];
	[self readSensorVoltageRange];
	[self readUnits];
	[self readSetPointTypes];
	[self readValveResponse];
	[self readBatteryStatus];
	[self readSoftwareVersion];
    [self readSystemStatus];
    [self readSensorType];
	[self readControlType];
    [self readSoftstartRates];
    [self readValveType];
	[self readThresholds];
	[self readPositionRange];
    [self readControlDirection];
}

- (void) readAndLoad
{
	[self addCmdToQueue:@"++StartDialogLoad" waitForResponse:NO];	
	[self readAndCompare];
	[self addCmdToQueue:@"++EndDialogLoad" waitForResponse:NO];	
}

- (void) writeSetPoints
{
	int i;
	for(i=0;i<5;i++){
        NSString* theCmd = [NSString stringWithFormat:@"S%d%05.1f",i+1, setPoint[i]];
        [self addCmdToQueue:theCmd waitForResponse:NO];
	}
	
	NSString* theCmd = [NSString stringWithFormat:@"S6%d",analogFSLevel];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readSetPoints];
}

- (void) writeSetPtSelection
{
	[self addCmdToQueue:[NSString stringWithFormat:@"D%d", setPtSelection+1] waitForResponse:NO];
}

- (void) writeZeroSensor
{
	[self addCmdToQueue:@"Z1" waitForResponse:NO];
}

- (void) writeSpecialZero
{
	[self addCmdToQueue:@"Z2" waitForResponse:NO];
}

- (void) writeRemoveZeroCorrection
{
	[self addCmdToQueue:@"Z3" waitForResponse:NO];
}

- (void) writeLearnAnalogZero
{
	[self addCmdToQueue:@"Z4" waitForResponse:NO];
}

- (void) writeCalibrateSpan
{
	[self addCmdToQueue:@"Y1" waitForResponse:NO];
}

- (void) writeLearnFullScale
{
	[self addCmdToQueue:@"Y2" waitForResponse:NO];
}

- (void) writeLearnSystem
{
	[self addCmdToQueue:@"L" waitForResponse:NO];
}

- (void) writeStopLearn
{
	[self addCmdToQueue:@"Q" waitForResponse:NO];
}


- (void) writeSetPointTypes
{
	int i;
	for(i=0;i<5;i++){
        NSString* theCmd = [NSString stringWithFormat:@"T%d%d",i+1, setPointType[i]];
        [self addCmdToQueue:theCmd waitForResponse:NO];
	}
	[self readSetPointTypes];
}

- (void) writeSoftStartRates
{
	int i;
	for(i=0;i<5;i++){
        NSString* theCmd = [NSString stringWithFormat:@"I%d%05.1f",i+1, softstartRate[i]];
        [self addCmdToQueue:theCmd waitForResponse:NO];
	}
	[self addCmdToQueue:[NSString stringWithFormat:@"I6%05.1f",analogSoftstart] waitForResponse:NO];
	[self addCmdToQueue:[NSString stringWithFormat:@"I7%05.1f",openSoftstart] waitForResponse:NO];
	[self addCmdToQueue:[NSString stringWithFormat:@"I8%05.1f",closeSoftstart] waitForResponse:NO];

	[self readSoftstartRates];
}

- (void) writeGainValues
{
	int i;
	for(i=0;i<5;i++){
        NSString* theCmd = [NSString stringWithFormat:@"M%d%05.1f",i+1, gainValue[i]];
        [self addCmdToQueue:theCmd waitForResponse:NO];
	}
	[self readGainValues];
}

- (void) writeLeadValues
{
	int i;
	for(i=0;i<5;i++){
        NSString* theCmd = [NSString stringWithFormat:@"X%d%05.1f",i+1, leadValue[i]];
        [self addCmdToQueue:theCmd waitForResponse:NO];
	}
	[self readLeadValues];
}

- (void) writeThresholds
{
	[self addCmdToQueue:[NSString stringWithFormat:@"P1%05.1f",lowThreshold[0]] waitForResponse:NO];
	[self addCmdToQueue:[NSString stringWithFormat:@"P2%05.1f",highThreshold[0]] waitForResponse:NO];
	[self addCmdToQueue:[NSString stringWithFormat:@"P3%05.1f",lowThreshold[1]] waitForResponse:NO];
	[self addCmdToQueue:[NSString stringWithFormat:@"P4%05.1f",highThreshold[1]] waitForResponse:NO];
	[self readThresholds];
}

- (void) writeOpenValve
{
	[self addCmdToQueue:@"O" waitForResponse:NO];
	[self readSystemStatus];
}

- (void) writeCloseValve
{
	[self addCmdToQueue:@"C" waitForResponse:NO];
	[self readSystemStatus];
}

- (void) writeHoldValve
{
	[self addCmdToQueue:@"H" waitForResponse:NO];
	[self readSystemStatus];
}

- (void) writeControlDirection
{
	[self addCmdToQueue:[NSString stringWithFormat:@"N%d",controlDirection] waitForResponse:NO];
	[self readControlDirection];
}

- (void) writeAnalogRange
{
	NSString* theCmd = [NSString stringWithFormat:@"A%d",analogRange];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readAnalogRange];
}

- (void) writeValveType
{
	NSString* theCmd = [NSString stringWithFormat:@"J%d",valveType];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readValveType];
}

- (void) writePositionRange
{
	NSString* theCmd = [NSString stringWithFormat:@"B%d",positionRange];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readPositionRange];
}

- (void) writeValveResponse
{
	NSString* theCmd = [NSString stringWithFormat:@"K%d",valveResponse];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readValveResponse];
}

- (void) writeControlType
{
	NSString* theCmd = [NSString stringWithFormat:@"V%d",controlType];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readControlType];
}

- (void) writeSensorRange
{
	NSString* theCmd = [NSString stringWithFormat:@"E%d",sensorRange];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readSensorRange];
}

- (void) writeSensorVoltageRange
{
	NSString* theCmd = [NSString stringWithFormat:@"G%d",sensorVoltageRange];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readSensorVoltageRange];
}

- (void) writeUnits
{
	NSString* theCmd = [NSString stringWithFormat:@"F%d",units];
	[self addCmdToQueue:theCmd waitForResponse:NO];
	[self readUnits];
}

#pragma mark •••Data Records
- (uint32_t) dataId { return dataId; }
- (void) setDataId: (uint32_t) DataId
{
    dataId = DataId;
}
- (void) setDataIds:(id)assigner
{
    dataId       = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherMks651c
{
    [self setDataId:[anotherMks651c dataId]];
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"Mks651cModel"];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
        @"ORMks651cDecoderForPressure",     @"decoder",
        [NSNumber numberWithLong:dataId],   @"dataId",
        [NSNumber numberWithBool:NO],       @"variable",
        [NSNumber numberWithLong:4],        @"length",
        nil];
    [dataDictionary setObject:aDictionary forKey:@"Pressures"];
    
    return dataDictionary;
}

- (void) pollHardware
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollHardware) object:nil];
	
	[self readPressures];
    [self readBatteryStatus];
    [self readSystemStatus];
	
    [self readChecksum];
	
	if(pollTime!=0){
		[self performSelector:@selector(pollHardware) withObject:nil afterDelay:pollTime];
	}
}

@end

@implementation ORMks651cModel (private)
- (void) runStarted:(NSNotification*)aNote
{
}

- (void) runStopped:(NSNotification*)aNote
{
}

- (void) timeout
{
	NSLogError(@"command timeout",@"MKS 651c",nil);
	[cmdQueue removeAllObjects];
	[self setLastRequest:nil];
}

- (void) processOneCommandFromQueue
{
	
	ORMks651cCmd* cmdObj = [cmdQueue dequeue];
	if(cmdObj){
		NSString* aCmd = cmdObj.cmd;
		if([aCmd isEqualToString:@"++ShipRecords"]){
			if(shipPressures) [self shipPressureValues];
			[self processOneCommandFromQueue];
		}
		else if([aCmd isEqualToString:@"++StartDialogLoad"]){
			loadDialog = YES;
		}
		else if([aCmd isEqualToString:@"++EndDialogLoad"]){
			loadDialog = NO;
		}
		else {
			if(cmdObj.waitForResponse) {
				[self performSelector:@selector(timeout) withObject:nil afterDelay:3];
				[self setLastRequest:aCmd];
			}
			else [self setLastRequest:nil];
			if(![aCmd hasSuffix:@"\r\n"]) aCmd = [aCmd stringByAppendingString:@"\r\n"];
			[serialPort writeString:aCmd];
			if(!lastRequest){
				[self processOneCommandFromQueue];
			}
		}
	}
}

- (void) process_response:(NSString*)theResponse
{	
	if(!lastRequest)return;
	
	int lastRequestNumber = [[lastRequest substringFromIndex:1] intValue];
	
	switch(lastRequestNumber){
		case 0:  [self decodeAnalogSetPoint:theResponse];			break;
			
		case 1:
		case 2:
		case 3:
		case 4:
		case 10:
					 [self decodeSetPoint:theResponse]; 
		break;
			
		case 5:		 [self decodeSystemPressure:theResponse];			break;
		case 7:		 [self decodeAlternateSystemStatus:theResponse];	break;
			
		case 11:	
		case 12:	
		case 13:	
		case 14:	
			 [self decodeThresholdLimits:theResponse];		break;
	
		case 15:
		case 16:
		case 17:
		case 18:
		case 19:
			 [self decodeSoftStartRate:theResponse]; 
		break;
			
		case 20:	 [self decodeAnalogSoftStart:theResponse];			break;
		case 21:	 [self decodeOpenSoftStart:theResponse];			break;
		case 22:	 [self decodeCloseSoftStart:theResponse];			break;
			
		case 23:	 [self decodeValveType:theResponse];				break;
		case 24:	 [self decodeAnalogRange:theResponse];				break;
			
		case 25:
		case 26:
		case 27:
		case 28:
		case 29:
		case 30:
					 [self decodeSetPointType:theResponse]; 
		break;
			
		case 31:	 [self decodePositionIndicatorRange:theResponse];	break;
		case 32:	 [self decodeDirectReverse:theResponse];			break;
		case 33:	 [self decodeSensorRange:theResponse];				break;
		case 34:	 [self decodePressureUnits:theResponse];			break;
		case 35:	 [self decodeSensorVoltageRange:theResponse];		break;
		case 36:	 [self decodeSensorType:theResponse];				break;
		case 37:	 [self decodeSystemStatus:theResponse];				break;
		case 38:	 [self decodeSoftwareVersion:theResponse];			break;
		case 39:	 [self decodeBatteryStatus:theResponse];			break;
		case 40:	 [self decodeValveResponseToPowerFail:theResponse];	break;
			
		case 41:
		case 42:
		case 43:
		case 44:
		case 45:
			 [self decodeLeadValue:theResponse];			
		break;

		case 46:
		case 47:
		case 48:
		case 49:
		case 50:
			 [self decodeGainValue:theResponse];			
		break;
	
		case 51:
			 [self decodeControlType:theResponse];			
		break;
			
	}
}

- (BOOL) decodeAnalogSoftStart:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"I6"]){
		float theValue = [[theResponse substringFromIndex:2] floatValue];
		if(loadDialog){
			[self setAnalogSoftstart:theValue];
			return YES;
		}
		if(fabs(analogSoftstart - theValue) < 0.1)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Analog Softstart ReadBack mismatch (%.1f != %.1f)\n",[self uniqueIdNumber],analogSoftstart,theValue);
	}
	return NO;	
}

- (BOOL) decodeOpenSoftStart:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"I7"]){
		float theValue = [[theResponse substringFromIndex:2] floatValue];
		if(loadDialog){
			[self setOpenSoftstart:theValue];
			return YES;
		}
		if(fabs(openSoftstart - theValue) < 0.1)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Open Softstart ReadBack mismatch (%.1f != %.1f)\n",[self uniqueIdNumber],openSoftstart,theValue);
	}
	return NO;	
}

- (BOOL) decodeCloseSoftStart:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"I7"]){
		float theValue = [[theResponse substringFromIndex:2] floatValue];
		if(loadDialog){
			[self setCloseSoftstart:theValue];
			return YES;
		}
		if(fabs(closeSoftstart - theValue) < 0.1)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Close Softstart ReadBack mismatch (%.1f != %.1f)\n",[self uniqueIdNumber],closeSoftstart,theValue);
	}
	return NO;	
}

- (BOOL) decodeAnalogSetPoint:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"S"]){
		int   index    = [[theResponse substringWithRange:NSMakeRange(1,1)] intValue];
		if(index==0){
			float theValue = [[theResponse substringFromIndex:2] floatValue];
			[self setAnalogSetPoint:theValue];
		}
    }
	return NO;	
}

- (BOOL) decodeSetPoint:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"S"]){
		//zero is the analog setpoint
		int   index    = [[theResponse substringWithRange:NSMakeRange(1,1)] intValue];
		if(index>=1 && index<=5){
			float theValue = [[theResponse substringFromIndex:2] floatValue];
			if(loadDialog){
				[self setSetPoint:index withValue:theValue];
				return YES;
			}
			if(fabs(setPoint[index-1] - theValue) < 0.1)return YES;
			else NSLogColor([NSColor redColor], @"MKS651 (%d) SetPoint %c ReadBack mismatch (%.1f != %.1f)\n",[self uniqueIdNumber],'A'+index,setPoint[index-1],theValue);
		}
    }
	return NO;	
}

- (BOOL) decodeGainValue:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"M"]){
        int   index    = [[theResponse substringWithRange:NSMakeRange(1,1)] intValue] - 1;
 		if(index>=0 && index<5){
			float theValue = [[theResponse substringFromIndex:2] floatValue];
			if(loadDialog){
				[self setGainValue:index withValue:theValue];
				return YES;
			}
			if(fabs(gainValue[index] - theValue) < 0.1)return YES;
			else NSLogColor([NSColor redColor], @"MKS651 (%d) Gain %c ReadBack mismatch (%.1f != %.1f)\n",[self uniqueIdNumber],'A'+index,gainValue[index],theValue);
		}
    }
	return NO;	
}

- (BOOL) decodeLeadValue:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"X"]){
        int   index    = [[theResponse substringWithRange:NSMakeRange(1,1)] intValue] - 1;
 		if(index>=0 && index<5){
			float theValue = [[theResponse substringFromIndex:2] floatValue];
			if(loadDialog){
				[self setLeadValue:index withValue:theValue];
				return YES;
			}
			if(fabs(leadValue[index] - theValue) < 0.1)return YES;
			else NSLogColor([NSColor redColor], @"MKS651 (%d) Lead %c ReadBack mismatch (%.1f != %.1f)\n",[self uniqueIdNumber],'A'+index,leadValue[index],theValue);
		}
    }
	return NO;	
}

- (BOOL) decodeAnalogRange:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"A"]){
        int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setAnalogRange:theValue];
			return YES;
		}
		if(theValue == analogRange)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Analog Range ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],analogRange,theValue);
	}
	return NO;
}

- (BOOL) decodeSensorVoltageRange:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"G"]){
        int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setSensorVoltageRange:theValue];
			return YES;
		}
		if(theValue == sensorVoltageRange)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Sensor Voltage Range ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],sensorVoltageRange,theValue);
	}
	return NO;
}

- (BOOL) decodeSensorRange:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"E"]){
		int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setSensorRange:theValue];
			return YES;
		}
		if(theValue == sensorRange)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Sensor Range ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],sensorRange,theValue);
	}
	return NO;
}

- (BOOL) decodePressureUnits:(NSString*)theResponse
{
	if ([theResponse hasPrefix:@"F"]){
		int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setUnits:theValue];
			return YES;
		}
		if(theValue == units)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Unit ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],units,theValue);
	}
	return NO;
}

- (BOOL) decodeSetPointType:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"T"]){
        int index    = [[theResponse substringWithRange:NSMakeRange(1,1)] intValue]-1;
  		if(index>=0 && index<5){
			int theValue = [[theResponse substringFromIndex:2] intValue];
			if(loadDialog){
				[self setSetPointType:index withValue:theValue];
				return YES;
			}
			if(setPointType[index] == theValue)return YES;
			else NSLogColor([NSColor redColor], @"MKS651 (%d) SetPointType %c ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],'A'+index,setPointType[index],theValue);
		}
	}
	return NO;
}

- (BOOL) decodeSoftStartRate:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"I"]){
        int   index    = [[theResponse substringWithRange:NSMakeRange(1,1)] intValue] - 1;
   		if(index>=0 && index<5){
			float theValue = [[theResponse substringFromIndex:2] floatValue];
			if(loadDialog){
				[self setSoftstartRate:index withValue:theValue];
				return YES;
			}
			if(fabs(softstartRate[index]-theValue)<.1)return YES;
			else NSLogColor([NSColor redColor], @"MKS651 (%d) Softstart %c ReadBack mismatch (%.1f != %.1f)\n",[self uniqueIdNumber],'A'+index,softstartRate[index],theValue);
		}
	}
	return NO;
}

- (BOOL) decodeValveResponseToPowerFail:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"K"]){
		int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setValveResponse:theValue];
			return YES;
		}
		if(valveResponse == theValue)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Valve response ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],valveResponse,theValue);
	}
	return NO;
}

- (BOOL) decodeSensorType:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"U"]){
		int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setSensorType:theValue];
			return YES;
		}
		if(sensorType == theValue)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Sensor type ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],sensorType,theValue);
	}
	return NO;
}

- (BOOL) decodeControlType:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"V"]){
		int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setControlType:theValue];
			return YES;
		}
		if(controlType == theValue)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Control Type ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],controlType,theValue);
    }
	return NO;	
}

- (BOOL) decodeValveType:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"J"]){
		int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setValveType:theValue];
			return YES;
		}
		if(valveType == theValue)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Valve Type ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],valveType,theValue);
    }
	return NO;	
}

- (BOOL) decodeSystemPressure:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"P"]){
		float theValue = [[theResponse substringFromIndex:1] floatValue];
		[self setPressure:theValue];
	}
	return NO;
}

- (BOOL) decodeAlternateSystemStatus:(NSString*)theResponse
{
	return NO;
}

- (BOOL) decodeThresholdLimits:(NSString*)theResponse
{	
    if([theResponse hasPrefix:@"P"]){
        int   index    = [[theResponse substringWithRange:NSMakeRange(1,1)] intValue];
		float theValue = [[theResponse substringFromIndex:2] floatValue];
		if(index==1){
			if(loadDialog)[self setLowThreshold:0 withValue:theValue];	
			else {
				if(fabs(theValue-lowThreshold[0])<.1)return YES;
				else NSLogColor([NSColor redColor], @"MKS651 (%d) Low Threshold 1 mismatch (%d != %d)\n",[self uniqueIdNumber],lowThreshold[0],theValue);
			}
		}
		else if(index==2){
			if(loadDialog)[self setHighThreshold:0 withValue:theValue];	
			else {
				if(fabs(theValue-highThreshold[0])<.1)return YES;
				else NSLogColor([NSColor redColor], @"MKS651 (%d) High Threshold 1 mismatch (%d != %d)\n",[self uniqueIdNumber],highThreshold[0],theValue);
			}
		}
		else if(index==3){
			if(loadDialog)[self setLowThreshold:1 withValue:theValue];	
			else {
				if(fabs(theValue-lowThreshold[1])<.1)return YES;
				else NSLogColor([NSColor redColor], @"MKS651 (%d) Low Threshold 1 mismatch (%d != %d)\n",[self uniqueIdNumber],lowThreshold[1],theValue);
			}
		}
		else if(index==4){
			if(loadDialog)[self setHighThreshold:1 withValue:theValue];	
			else {
				if(fabs(theValue-highThreshold[1])<.1)return YES;
				else NSLogColor([NSColor redColor], @"MKS651 (%d) High Threshold 1 mismatch (%d != %d)\n",[self uniqueIdNumber],highThreshold[1],theValue);
			}
		}
		if(loadDialog)return YES;
    }
	return NO;	
}

- (BOOL) decodePositionIndicatorRange:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"B"]){
		int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setPositionRange:theValue];
			return YES;
		}
		if(positionRange == theValue)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Valve Position Range ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],positionRange,theValue);
    }
	return NO;	
}

- (BOOL) decodeDirectReverse:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"N"]){
		int theValue = [[theResponse substringFromIndex:1] intValue];
		if(loadDialog){
			[self setControlDirection:theValue];
			return YES;
		}
		if(controlDirection == theValue)return YES;
		else NSLogColor([NSColor redColor], @"MKS651 (%d) Valve Control Direction ReadBack mismatch (%d != %d)\n",[self uniqueIdNumber],controlDirection,theValue);
    }
	return NO;	
}

- (BOOL) decodeSystemStatus:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"M"]){
		[self setLocal:			[[theResponse substringWithRange:NSMakeRange(1,1)] intValue]];
		[self setLearning:		[[theResponse substringWithRange:NSMakeRange(2,1)] intValue]];
		[self setSystemStatus:	[[theResponse substringWithRange:NSMakeRange(3,1)] intValue]];
		return YES;
	}
	else return NO;
}

- (BOOL) decodeSoftwareVersion:(NSString*)theResponse
{
    if([theResponse hasPrefix:@"H"]){
        [self setSoftwareVersion:[[theResponse substringFromIndex:8] floatValue]];
		return YES;
    }
	else return NO;
}

- (BOOL) decodeBatteryStatus:(NSString*)theResponse
{
	if([theResponse hasPrefix:@"BT"]){		
		int theValue = [[theResponse substringFromIndex:2] intValue];
		[self setBatteryStatus:theValue];
		return YES;
	}
	else return NO;
}
- (float) limitFloatValue:(float)aValue min:(float)aMin max:(float)aMax
{
	if(aValue<aMin)return aMin;
	else if(aValue>aMax)return aMax;
	else return aValue;
}

@end

@implementation ORMks651cCmd
@synthesize cmd,waitForResponse;
- (void) dealloc
{
	self.cmd		 = nil;
	[super dealloc];
}
@end
