//--------------------------------------------------------
// ORGT521Model
// Created by Mark  A. Howe on Oct 31, 2013
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2013 CENPA, University of North Carolina. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of
//North Carolina sponsored in part by the United States
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020.
//The University has certain rights in the program pursuant to
//the contract and the program should not be copied or distributed
//outside your organization.  The DOE and the University of
//North Carolina reserve all rights in the program. Neither the authors,
//University of North Carolina, or U.S. Government make any warranty,
//express or implied, or assume any liability or responsibility
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORGT521Model.h"
#import "ORSerialPortAdditions.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"
#import "ORTimeRate.h"
#import "ORAlarm.h"

#pragma mark ***External Strings
NSString* ORGT521ModelProbeAttachedChanged  = @"ORGT521ModelProbeAttachedChanged";
NSString* ORGT521ModelCorrectionTypeChanged = @"ORGT521ModelCorrectionTypeChanged";
NSString* ORGT521ModelAutoCountChanged      = @"ORGT521ModelAutoCountChanged";
NSString* ORGT521ModelTemperatureChanged    = @"ORGT521ModelTemperatureChanged";
NSString* ORGT521ModelHumidityChanged       = @"ORGT521ModelHumidityChanged";
NSString* ORGT521ModelLocationChanged       = @"ORGT521ModelLocationChanged";
NSString* ORGT521ModelCycleNumberChanged	= @"ORGT521ModelCycleNumberChanged";
NSString* ORGT521ModelCycleWillEndChanged	= @"ORGT521ModelCycleWillEndChanged";
NSString* ORGT521ModelCycleStartedChanged	= @"ORGT521ModelCycleStartedChanged";
NSString* ORGT521ModelRunningChanged		= @"ORGT521ModelRunningChanged";
NSString* ORGT521ModelCycleDurationChanged  = @"ORGT521ModelCycleDurationChanged";
NSString* ORGT521ModelCountingModeChanged	= @"ORGT521ModelCountingModeChanged";
NSString* ORGT521ModelCount2Changed         = @"ORGT521ModelCount2Changed";
NSString* ORGT521ModelCount1Changed         = @"ORGT521ModelCount1Changed";
NSString* ORGT521ModelSize2Changed			= @"ORGT521ModelSize2Changed";
NSString* ORGT521ModelSize1Changed			= @"ORGT521ModelSize1Changed";
NSString* ORGT521ModelMeasurementDateChanged = @"ORGT521ModelMeasurementDateChanged";
NSString* ORGT521ModelMissedCountChanged	= @"ORGT521ModelMissedCountChanged";
NSString* ORGT521ModelValueAlarmLimitChanged= @"ORGT521ModelValueAlarmLimitChanged";
NSString* ORGT521ModelMaxValueChanged      = @"ORGT521ModelMaxValueChanged";

NSString* ORGT521Lock = @"ORGT521Lock";

@interface ORGT521Model (private)
- (void) timeout;
- (void) processOneCommandFromQueue;
- (void) process_response:(NSString*)theResponse;
- (void) goToNextCommand;
- (void) startTimeOut;
- (void) checkCycle;
- (void) processStatus:(NSString*)aString;
- (void) clearDelay;
- (void) startDataArrivalTimeout;
- (void) cancelDataArrivalTimeout;
- (void) doCycleKick;
- (void) postCouchDBRecord;
- (void) doStartUpCommands;

@end

@implementation ORGT521Model

#define kGT521CmdTimeout  10

- (id) init
{
	self = [super init];
	int i;
	for(i=0;i<2;i++){
		[self setIndex:i maxValue:1000];
		[self setIndex:i valueAlarmLimit:800];
	}
    [self setIndex:2 maxValue:100];
    [self setIndex:2 valueAlarmLimit:50];
    [self setIndex:3 maxValue:100];
    [self setIndex:3 valueAlarmLimit:50];
    return self;
}

- (void) dealloc
{
    [cycleWillEnd release];
    [cycleStarted release];
    [measurementDate release];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [missingCyclesAlarm clearAlarm];
	[missingCyclesAlarm release];
    [buffer release];
	
	int i;
	for(i=0;i<4;i++){
		[timeRates[i] release];
	}	
	[super dealloc];
}

- (void) sleep
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[super sleep];
}

- (void) wakeUp
{
	[super wakeUp];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"GT521.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORGT521Controller"];
}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		
        
        NSString* theString = [[[[NSString alloc] initWithData:[[note userInfo] objectForKey:@"data"] 
												      encoding:NSASCIIStringEncoding] autorelease] uppercaseString];
		
		[self process_response:theString];
	}
}

#pragma mark ***Accessors

- (BOOL) probeAttached
{
    return probeAttached;
}

- (void) setProbeAttached:(BOOL)aProbeAttached
{
    probeAttached = aProbeAttached;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelProbeAttachedChanged object:self];
}

- (int) correctionType
{
    return correctionType;
}

- (void) setCorrectionType:(int)aCorrectionType
{
    correctionType = aCorrectionType;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCorrectionTypeChanged object:self];
}

- (BOOL) autoCount
{
    return autoCount;
}

- (void) setAutoCount:(BOOL)aAutoCount
{
    autoCount = aAutoCount;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelAutoCountChanged object:self];
}

- (float) temperature
{
    return temperature;
}

- (void) setTemperature:(float)aTemperature
{
    temperature = aTemperature;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelTemperatureChanged object:self];
	if(timeRates[3] == nil) timeRates[3] = [[ORTimeRate alloc] init];
	[timeRates[3] addDataToTimeAverage:humidity];
}

- (float) humidity
{
    return humidity;
}

- (void) setHumidity:(float)aHumidity
{
    humidity = aHumidity;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelHumidityChanged object:self];

	if(timeRates[2] == nil) timeRates[2] = [[ORTimeRate alloc] init];
	[timeRates[2] addDataToTimeAverage:humidity];

}

- (int) location
{
    return location;
}

- (void) setLocation:(int)aLocation
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLocation:location];
    
    location = aLocation;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelLocationChanged object:self];
}
- (int) missedCycleCount
{
    return missedCycleCount;
}

- (void) setMissedCycleCount:(int)aValue
{
    missedCycleCount = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelMissedCountChanged object:self];
    
	if(missedCycleCount >= 3){
		if(!missingCyclesAlarm){
			NSString* s = [NSString stringWithFormat:@"GT521 (Unit %u) Missing Cycles",[self uniqueIdNumber]];
			missingCyclesAlarm = [[ORAlarm alloc] initWithName:s severity:kHardwareAlarm];
			[missingCyclesAlarm setSticky:YES];
            [missingCyclesAlarm setHelpString:@"The particle counter is not reporting counts at the end of its cycle. ORCA tried to kick start it at least three times.\n\nThis alarm will not go away until the problem is cleared. Acknowledging the alarm will silence it."];
			[missingCyclesAlarm postAlarm];
		}
	}
	else {
		[missingCyclesAlarm clearAlarm];
		[missingCyclesAlarm release];
		missingCyclesAlarm = nil;
	}
    
}
- (BOOL) dataForChannelValid:(int)aChannel
{
    return dataValid && [serialPort isOpen];
}

- (float) valueAlarmLimit:(int)index
{
	if(index>=0 && index<4) return valueAlarmLimit[index];
	else return 0;
}

- (void) setIndex:(int)index valueAlarmLimit:(float)aValue
{
	if(index<0 || index>=8)return;
	[[[self undoManager] prepareWithInvocationTarget:self] setIndex:index valueAlarmLimit:valueAlarmLimit[index]];
    valueAlarmLimit[index] = aValue;
	NSMutableDictionary* userInfo = [NSMutableDictionary dictionary];
	[userInfo setObject:[NSNumber numberWithInt:index] forKey: @"Channel"];
    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelValueAlarmLimitChanged object:self userInfo:userInfo];
}

- (float) maxValue:(int)index
{
	if(index>=0 && index<4) return maxValue[index];
	else return 0;
}

- (void) setIndex:(int)index maxValue:(float)aValue
{
	if(index<0 || index>=4)return;
	[[[self undoManager] prepareWithInvocationTarget:self] setIndex:index maxValue:maxValue[index]];
	maxValue[index] = aValue;
	NSMutableDictionary* userInfo = [NSMutableDictionary dictionary];
	[userInfo setObject:[NSNumber numberWithInt:index] forKey: @"Channel"];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelMaxValueChanged object:self  userInfo:userInfo];
}

- (ORTimeRate*)timeRate:(int)index
{
	return timeRates[index];
}

- (int) cycleNumber
{
    return cycleNumber;
}

- (void) setCycleNumber:(int)aCycleNumber
{
    cycleNumber = aCycleNumber;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCycleNumberChanged object:self];
}

- (NSDate*) cycleWillEnd
{
    return cycleWillEnd;
}

- (void) setCycleWillEnd:(NSDate*)aCycleWillEnd
{
    [aCycleWillEnd retain];
    [cycleWillEnd release];
    cycleWillEnd = aCycleWillEnd;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCycleWillEndChanged object:self];
}

- (NSDate*) cycleStarted
{
    return cycleStarted;
}

- (void) setCycleStarted:(NSDate*)aCycleStarted
{
    [aCycleStarted retain];
    [cycleStarted release];
    cycleStarted = aCycleStarted;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCycleStartedChanged object:self];
}

- (BOOL) running
{
    return running;
}

- (void) setRunning:(BOOL)aRunning
{
    running = aRunning;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelRunningChanged object:self];
}

- (int) cycleDuration
{
    return cycleDuration;
}

- (void) setCycleDuration:(int)aCycleDuration
{
	if(aCycleDuration == 0) aCycleDuration = 1;
    [[[self undoManager] prepareWithInvocationTarget:self] setCycleDuration:cycleDuration];
    
    cycleDuration = aCycleDuration;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCycleDurationChanged object:self];
}

- (int) countingMode
{
    return countingMode;
}

- (void) setCountingMode:(int)aCountingMode
{
    countingMode = aCountingMode;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCountingModeChanged object:self];
}

- (NSString*) countingModeString
{
	switch ([self countingMode]) {
		case kGT521Cumulative:      return @"Cumulative";
		case kGT521Differential:    return @"Differential";
		case kGT521Uncorrected:     return @"Uncorrected";
		default:                    return @"--";
	}
}

- (int) count2
{
    return count2;
}

- (void) setCount2:(int)aCount2
{
    count2 = aCount2;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCount2Changed object:self];
	if(timeRates[1] == nil) timeRates[1] = [[ORTimeRate alloc] init];
	[timeRates[1] addDataToTimeAverage:count2];
}

- (int) count1
{
    return count1;
}

- (void) setCount1:(int)aCount1
{
    count1 = aCount1;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCount1Changed object:self];
	if(timeRates[0] == nil) timeRates[0] = [[ORTimeRate alloc] init];
	[timeRates[0] addDataToTimeAverage:count1];
}

- (float) size2
{
    return size2;
}

- (void) setSize2:(float)aSize2
{
    size2 = aSize2;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelSize2Changed object:self];
}

- (float) size1
{
    return size1;
}

- (void) setSize1:(float)aSize1
{
    size1 = aSize1;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelSize1Changed object:self];
}

- (NSString*) measurementDate
{
	if(!measurementDate)return @"";
    else return measurementDate;
}

- (void) setMeasurementDate:(NSString*)aMeasurementDate
{
    [measurementDate autorelease];
    measurementDate = [aMeasurementDate copy];    

    [[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelMeasurementDateChanged object:self];
}

- (uint32_t) timeMeasured
{
	return timeMeasured;
}

- (NSString*) lastRequest
{
	return lastRequest;
}

- (void) setLastRequest:(NSString*)aRequest
{
	[lastRequest autorelease];
	lastRequest = [aRequest copy];    
}


- (void) setUpPort
{
	[serialPort setSpeed:9600];
	[serialPort setParityNone];
	[serialPort setStopBits2:NO];
	[serialPort setDataBits:8];
}

- (void) firstActionAfterOpeningPort
{
	if(wasRunning)[self startCycle];
}

#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setLocation:[decoder decodeIntForKey:@"location"]];
	wasRunning = [decoder decodeBoolForKey:@"wasRunning"];
	[self setCycleDuration:		[decoder decodeIntForKey:@"cycleDuration"]];

    int i;
	for(i=0;i<4;i++){
		timeRates[i] = [[ORTimeRate alloc] init];
		[self setIndex:i valueAlarmLimit:  	[decoder decodeFloatForKey: [NSString stringWithFormat:@"valueAlarmLimit%d",i]]];
		[self setIndex:i maxValue:			[decoder decodeFloatForKey: [NSString stringWithFormat:@"maxValue%d",i]]];
	}
    if(location<=0)location = 1;
    
	[[self undoManager] enableUndoRegistration];
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeInteger:     location        forKey:@"location"];
    [encoder encodeInteger:		cycleDuration	forKey:@"cycleDuration"];
    [encoder encodeBool:	wasRunning		forKey:	@"wasRunning"];
	int i;
	for(i=0;i<4;i++){
		[encoder encodeFloat:	valueAlarmLimit[i]  forKey: [NSString stringWithFormat:@"valueAlarmLimit%d",i]];
		[encoder encodeFloat:	maxValue[i]         forKey: [NSString stringWithFormat:@"maxValue%d",i]];
	}
}

#pragma mark *** Commands
- (void) addCmdToQueue:(NSString*)aCmd
{
   if([serialPort isOpen]){
       if(![aCmd hasSuffix:@"\r\n"]) aCmd = [aCmd stringByAppendingFormat:@"\r\n"];
	   [self enqueueCmd:aCmd];
	   [self enqueueCmd:@"++Delay"];
		if(!lastRequest){
			[self processOneCommandFromQueue];
		}
	}
}

- (void) startCounting				{ [self addCmdToQueue:@"S"]; }
- (void) stopCounting				{ [self addCmdToQueue:@"E"]; }
- (void) clearBuffer				{ [self addCmdToQueue:@"B\r\nY"];}
- (void) getFirmwareVersion			{ [self addCmdToQueue:@"Q"]; }
- (void) getLastRecord				{ [self addCmdToQueue:@"L"]; }
- (void) selectUnit                 { [self addCmdToQueue:[NSString stringWithFormat:@"U%d",location]]; }
- (void) setSampleTime              { [self addCmdToQueue:[NSString stringWithFormat:@"T%d",cycleDuration*60]]; }

#pragma mark ***Polling and Cycles
- (void) startCycle
{
    [self startCycle:NO];
}
- (void) startCycle:(BOOL)force
{
	if((![self running] || force) && [serialPort isOpen]){
		[self setRunning:YES];
        restart = YES;
		[self setCycleNumber:0];
        [self doStartUpCommands];
		NSLog(@"GT521(%d) Starting particle counter\n",[self uniqueIdNumber]);
	}
}

- (void) stopCycle
{
	if([self running] && [serialPort isOpen]){
        restart = NO;
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(checkCycle) object:nil];
		[self setRunning:NO];
		[self setCycleNumber:0];
		[self stopCounting];
		[self getLastRecord];
        [self cancelDataArrivalTimeout];
		NSLog(@"GT521(%d) Stopping particle counter\n",[self uniqueIdNumber]);
	}
}

#pragma mark •••Bit Processing Protocol
- (void) processIsStarting
{
	if(!running){
		if(!sentStartOnce){
			sentStartOnce = YES;
			sentStopOnce = NO;
            wasRunning = NO;
			
			[self startCycle:YES];
		}
	}
    else wasRunning = YES;

}

- (void) processIsStopping
{
	if(!wasRunning){
		if(!sentStopOnce){
			sentStopOnce = YES;
			sentStartOnce = NO;
			[self stopCycle];
		}
	}
}

//note that everything called by these routines MUST be threadsafe
- (void) startProcessCycle
{    
	@try { 
	}
	@catch(NSException* localException) { 
		//catch this here to prevent it from falling thru, but nothing to do.
	}
}

- (void) endProcessCycle
{
}

- (NSString*) identifier
{
	NSString* s;
 	@synchronized(self){
		s= [NSString stringWithFormat:@"GT521,%u",[self uniqueIdNumber]];
	}
	return s;
}

- (NSString*) processingTitle
{
	NSString* s;
 	@synchronized(self){
		s= [self identifier];
	}
	return s;
}

- (double) convertedValue:(int)aChan
{
	double theValue;
	@synchronized(self){
        switch(aChan){
            case 0: theValue = [self count1]; break;
            case 1: theValue = [self count2]; break;
            case 2: theValue = [self humidity]; break;
            case 3: theValue = [self temperature]; break;
            default: theValue = 0; break;
        }
	}
	return theValue;
}

- (double) maxValueForChan:(int)aChan
{
	double theValue = 0;
	@synchronized(self){
        if(aChan>=0 && aChan<4){
            theValue = (double)[self maxValue:aChan];
        }
	}
	return theValue;
}

- (double) minValueForChan:(int)aChan
{
	return 0;
}

- (void) getAlarmRangeLow:(double*)theLowLimit high:(double*)theHighLimit channel:(int)aChan
{
	@synchronized(self){
        if(aChan>=0 && aChan<4){
            *theLowLimit = -.001;
            *theHighLimit =  [self valueAlarmLimit:aChan];
        }
	}
}

- (BOOL) processValue:(int)aChan
{
	BOOL r;
	@synchronized(self){
		r = YES;    //temp -- figure out what the process bool for this object should be.
	}
	return r;
}

- (void) setProcessOutput:(int)aChan value:(int)value
{
    //nothing to do. not used in adcs. really shouldn't be in the protocol
}

@end

@implementation ORGT521Model (private)
- (void) doStartUpCommands
{
    NSDate* now = [NSDate date];
    [self setCycleStarted:now];
    NSDate* endTime = [now dateByAddingTimeInterval:[self cycleDuration]*60];
    [self setCycleWillEnd:endTime];
    [self clearBuffer];
    [self setSampleTime];
    [self startCounting];
    [self checkCycle];
    [self setCycleNumber:cycleNumber+1];
    [self startDataArrivalTimeout];
}

- (void) postCouchDBRecord
{
    NSDictionary* values = [NSDictionary dictionaryWithObjectsAndKeys:
                            [NSArray arrayWithObjects:
                             [NSNumber numberWithInt:count1],
                             [NSNumber numberWithInt:count2],
                             [NSNumber numberWithFloat:humidity],
                             [NSNumber numberWithFloat:temperature],
                              nil], @"counts",
                            [NSNumber numberWithInt:    cycleDuration],    @"pollTime",
                            nil];
    [[NSNotificationCenter defaultCenter] postNotificationName:@"ORCouchDBAddObjectRecord" object:self userInfo:values];
}

- (void) checkCycle
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(checkCycle) object:nil];
	if(running){
		NSDate* now = [NSDate date];
		if([cycleWillEnd timeIntervalSinceDate:now] >= 0){
			[[NSNotificationCenter defaultCenter] postNotificationName:ORGT521ModelCycleWillEndChanged object:self];
			[self performSelector:@selector(checkCycle) withObject:nil afterDelay:2];
		}
	}
}

- (void) startDataArrivalTimeout
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(doCycleKick) object:nil];
    [self performSelector:@selector(doCycleKick)  withObject:nil afterDelay:((cycleDuration*60)+120)];
}

- (void) cancelDataArrivalTimeout
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(doCycleKick) object:nil];
}

- (void) doCycleKick
{
    [self setMissedCycleCount:missedCycleCount+1];
    NSLogColor([NSColor redColor],@"%@ data did not arrive at end of cycle (missed %d)\n",[self fullID],missedCycleCount);
	NSLogColor([NSColor redColor],@"Kickstarting %@\n",[self fullID]);		
	[self stopCycle];
	[self startCycle:YES];
}

- (void) timeout
{
	[super timeout];
}

- (void) recoverFromTimeout
{
}

- (void) goToNextCommand
{
	[self setLastRequest:nil];			 //clear the last request
	[self processOneCommandFromQueue];	 //do the next command in the queue
}

- (void) clearDelay
{
	delay = NO;
	[self processOneCommandFromQueue];
}

- (void) processOneCommandFromQueue
{
	if(delay)return;
	
	NSString* aCmd = [self nextCmd];
	if(aCmd){
		if([aCmd isEqualToString:@"++Delay"]){
			delay = YES;
			[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(clearDelay) object:nil];
			[self performSelector:@selector(clearDelay) withObject:nil afterDelay:kGT521DelayTime];
		}
		else {
			[self setLastRequest:aCmd];
			[self startTimeOut];
			[serialPort writeString:[NSString stringWithFormat:@"U%d\r\n",location]];
			[serialPort writeString:aCmd];
		}
	}
	if(!lastRequest){
		[self performSelector:@selector(processOneCommandFromQueue) withObject:nil afterDelay:3];
	}
}

- (void) process_response:(NSString*)theResponse
{
    if(!buffer)buffer = [[NSMutableString string] retain];
    [buffer appendString:theResponse];
    while([buffer rangeOfString:@"\r\n"].location!=NSNotFound){
        NSRange r = [buffer rangeOfString:@"\r\n"];
        NSString* line = [buffer substringToIndex:r.location];
        [buffer deleteCharactersInRange:NSMakeRange(0,r.location+r.length)];
        if([line length]>2){
            NSArray* parts = [line componentsSeparatedByString:@","];
            if([parts count] >= 10){
                NSString* datePart		= [parts objectAtIndex:0];
                NSString* timePart		= [parts objectAtIndex:1];
                //id is part 2
                NSString* size1Part		= [parts objectAtIndex:3];
                NSString* count1Part	= [parts objectAtIndex:4];
                NSString* size2Part		= [parts objectAtIndex:5];
                NSString* count2Part	= [parts objectAtIndex:6];
                NSString* humidityPart	= [parts objectAtIndex:7];
                NSString* tempPart      = [parts objectAtIndex:8];
                NSString* statusPart    = [parts objectAtIndex:9];
                
                if([datePart length] >= 6 && [timePart length] >= 6){
                    [self setMeasurementDate: [NSString stringWithFormat:@"%02d/%02d/%02d %02d:%02d:%02d",
                                               [[datePart substringWithRange:NSMakeRange(0,2)]intValue],
                                               [[datePart substringWithRange:NSMakeRange(3,2)]intValue],
                                               [[datePart substringWithRange:NSMakeRange(6,4)]intValue],
                                               [[timePart substringWithRange:NSMakeRange(0,2)]intValue],
                                               [[timePart substringWithRange:NSMakeRange(3,2)]intValue],
                                               [[timePart substringWithRange:NSMakeRange(6,2)]intValue]
                                               ]];
                }
                
                [self setSize1:      [size1Part floatValue]];
                [self setCount1:     [count1Part intValue]];
                [self setSize2:      [size2Part floatValue]];
                [self setCount2:     [count2Part intValue]];
                [self setHumidity:   [humidityPart floatValue]];
                [self setTemperature:[tempPart floatValue]];
                
                [self processStatus:statusPart];
                
                  
                [self setMissedCycleCount:0];
                [self startDataArrivalTimeout];
                
                [self postCouchDBRecord];
                dataValid = YES;
                
                if(restart){
                    [self doStartUpCommands];
                }

            }
        }
    }
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
    [self performSelector:@selector(goToNextCommand) withObject:nil afterDelay:1];
}

- (void) processStatus:(NSString*)aString
{
    [self setAutoCount:    ([aString rangeOfString:@"A"].location != NSNotFound)];
    [self setProbeAttached:([aString rangeOfString:@"S"].location != NSNotFound)];
    
    if([aString rangeOfString:@"I"].location != NSNotFound) [self setCountingMode:kGT521Cumulative];
    else if([aString rangeOfString:@"D"].location != NSNotFound)[self setCountingMode:kGT521Differential];
    else if([aString rangeOfString:@"U"].location != NSNotFound)[self setCountingMode:kGT521Uncorrected];
    
    if([aString rangeOfString:@"Q"].location != NSNotFound)      [self setCorrectionType:kGT521CubicFoot];
    else if([aString rangeOfString:@"Z"].location != NSNotFound) [self setCorrectionType:kGT521CubicLiter];
}

- (void) startTimeOut
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	[self performSelector:@selector(timeout) withObject:nil afterDelay:kGT521CmdTimeout];
}
@end
