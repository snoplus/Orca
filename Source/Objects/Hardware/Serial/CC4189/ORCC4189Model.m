//--------------------------------------------------------
// ORCC4189Model
// Created by Mark  A. Howe on Fri Jul 22 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORCC4189Model.h"
#import "ORSerialPortAdditions.h"
#import "ORDataTypeAssigner.h"
#import "ORDataPacket.h"
#import "ORTimeRate.h"

#pragma mark ***External Strings
NSString* ORCC4189ModelHighLimit1Changed = @"ORCC4189ModelHighLimit1Changed";
NSString* ORCC4189ModelHighLimit0Changed = @"ORCC4189ModelHighLimit0Changed";
NSString* ORCC4189ModelLowLimit1Changed = @"ORCC4189ModelLowLimit1Changed";
NSString* ORCC4189ModelLowLimit0Changed = @"ORCC4189ModelLowLimit0Changed";
NSString* ORCC4189ModelShipValuesChanged = @"ORCC4189ModelShipValuesChanged";
NSString* ORCC4189TemperatureChanged	= @"ORCC4189TemperatureChanged";
NSString* ORCC4189HumidityChanged		= @"ORCC4189HumidityChanged";

NSString* ORCC4189Lock = @"ORCC4189Lock";

@implementation ORCC4189Model
- (id) init
{
	self = [super init];
	lowLimit0 = 0;
	highLimit0 = 100;
	lowLimit1 = 0;
	highLimit1 = 100;
	
	return self;
}

- (void) dealloc
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [buffer release];
	int i;
	for(i=0;i<2;i++){
		[timeRates[i] release];
	}
	
	[super dealloc];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"CC4189"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORCC4189Controller"];
}

//- (NSString*) helpURL
//{
//	return @"RS232/LakeShore_210.html";
//}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		//[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
        NSString* theString = [[[[NSString alloc] initWithData:[[note userInfo] objectForKey:@"data"] 
												      encoding:NSASCIIStringEncoding] autorelease] uppercaseString];
        if(!buffer)buffer = [[NSMutableString string] retain];
        [buffer appendString:theString];
		
        do {
            NSRange lineRange = [buffer rangeOfString:@"\r"];
            if(lineRange.location!= NSNotFound){
                NSMutableString* theResponse = [[[buffer substringToIndex:lineRange.location+1] mutableCopy] autorelease];
                [buffer deleteCharactersInRange:NSMakeRange(0,lineRange.location+1)];      //take the cmd out of the buffer
				//get the different parts
				float theNumber = [[theResponse substringWithRange:NSMakeRange(7,8)] floatValue];
				float precision   = [[theResponse substringWithRange:NSMakeRange(6,1)] floatValue];
				int sign   = [[theResponse substringWithRange:NSMakeRange(5,1)] intValue];
				int symbol = [[theResponse substringWithRange:NSMakeRange(3,2)] intValue];
				int end    = [[theResponse substringWithRange:NSMakeRange(1,1)] intValue];
				if(end == 4){
					theNumber = theNumber / powf(10.,precision);
					if(sign == 1)theNumber *= -1;
					if(symbol == 4)[self setHumidity:theNumber];
					else if(symbol == 1)[self setTemperature:theNumber];
					else if(symbol == 2){
						[self setTemperature:(5/9.)*(theNumber-32.)];
					}
				}
            }
        } while([buffer rangeOfString:@"\r"].location!= NSNotFound);
		if(temperature!=0 && humidity!=0) readOnce = YES;
        
        [self postCouchDBRecord];

	}
}


- (void) shipAllValues
{
    if([[ORGlobal sharedGlobal] runInProgress]){
		
		union {
			float asFloat;
			uint32_t asLong;
		}theData;
		
		uint32_t data[5];
		data[0] = dataId | 4;
		data[1] =  ([self uniqueIdNumber]&0x0000fffff);
		
		theData.asFloat = temperature;
		data[2] = theData.asLong;
		
		theData.asFloat = humidity;
		data[3] = theData.asLong;
		
		data[4] = timeMeasured;
		
		[[NSNotificationCenter defaultCenter] postNotificationName:ORQueueRecordForShippingNotification 
															object:[NSData dataWithBytes:data length:sizeof(int32_t)*4]];
	}
}


#pragma mark ***Accessors

- (double) highLimit1
{
    return highLimit1;
}

- (void) setHighLimit1:(double)aHighLimit1
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHighLimit1:highLimit1];
    
    highLimit1 = aHighLimit1;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCC4189ModelHighLimit1Changed object:self];
}

- (double) highLimit0
{
    return highLimit0;
}

- (void) setHighLimit0:(double)aHighLimit0
{
    [[[self undoManager] prepareWithInvocationTarget:self] setHighLimit0:highLimit0];
    
    highLimit0 = aHighLimit0;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCC4189ModelHighLimit0Changed object:self];
}

- (double) lowLimit1
{
    return lowLimit1;
}

- (void) setLowLimit1:(double)aLowLimit1
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLowLimit1:lowLimit1];
    
    lowLimit1 = aLowLimit1;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCC4189ModelLowLimit1Changed object:self];
}

- (double) lowLimit0
{
    return lowLimit0;
}

- (void) setLowLimit0:(double)aLowLimit0
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLowLimit0:lowLimit0];
    
    lowLimit0 = aLowLimit0;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCC4189ModelLowLimit0Changed object:self];
}
- (ORTimeRate*)timeRate:(int)index
{
	return timeRates[index];
}

- (BOOL) shipValues
{
    return shipValues;
}

- (void) setShipValues:(BOOL)aFlag
{
    [[[self undoManager] prepareWithInvocationTarget:self] setShipValues:shipValues];
    
    shipValues = aFlag;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORCC4189ModelShipValuesChanged object:self];
}

- (uint32_t) timeMeasured
{
	return timeMeasured;
}

- (float) temperature
{
	return temperature;
}
									
- (void) setTemperature:(float)aValue;
{
	temperature = aValue;
	//get the time(UT!)
	time_t	ut_Time;
	time(&ut_Time);
	//struct tm* theTimeGMTAsStruct = gmtime(&theTime);
	timeMeasured = (uint32_t)ut_Time;

	[[NSNotificationCenter defaultCenter] postNotificationName:ORCC4189TemperatureChanged 
														object:self 
													userInfo:nil];

	if(timeRates[0] == nil) timeRates[0] = [[ORTimeRate alloc] init];
	[timeRates[0] addDataToTimeAverage:aValue];

}
									
- (float) humidity
{
	return humidity;
}
				
- (void) setHumidity:(float)aValue;
{
	humidity = aValue;
	
	[[NSNotificationCenter defaultCenter] postNotificationName:ORCC4189HumidityChanged 
														object:self 
													  userInfo:nil];
	
	if(timeRates[1] == nil) timeRates[1] = [[ORTimeRate alloc] init];
	[timeRates[1] addDataToTimeAverage:aValue];
	
}
									
- (void) openPort:(BOOL)state
{
    if(state) {
		[serialPort setSpeed:9600];
		[serialPort setParityOdd];
		[serialPort setStopBits2:1];
		[serialPort setDataBits:7];
        [serialPort open];
    }
    else      [serialPort close];
    portWasOpen = [serialPort isOpen];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORSerialPortModelPortStateChanged object:self];
    
}

#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setHighLimit1:[decoder decodeDoubleForKey:@"highLimit1"]];
	[self setHighLimit0:[decoder decodeDoubleForKey:@"highLimit0"]];
	[self setLowLimit1:[decoder decodeDoubleForKey:@"lowLimit1"]];
	[self setLowLimit0:[decoder decodeDoubleForKey:@"lowLimit0"]];
	[self setShipValues:	[decoder decodeBoolForKey:@"shipValues"]];
	[[self undoManager] enableUndoRegistration];
	int i;
	for(i=0;i<2;i++)timeRates[i] = [[ORTimeRate alloc] init];

	return self;
}
- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeDouble:highLimit1 forKey:@"highLimit1"];
    [encoder encodeDouble:highLimit0 forKey:@"highLimit0"];
    [encoder encodeDouble:lowLimit1 forKey:@"lowLimit1"];
    [encoder encodeDouble:lowLimit0 forKey:@"lowLimit0"];
    [encoder encodeBool:shipValues forKey:@"shipValues"];
}

#pragma mark ***Data Records
- (uint32_t) dataId { return dataId; }
- (void) setDataId: (uint32_t) DataId
{
    dataId = DataId;
}
- (void) setDataIds:(id)assigner
{
    dataId       = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherCC4189
{
    [self setDataId:[anotherCC4189 dataId]];
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"CC4189Model"];
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
        @"ORCC4189DecoderForValues",		@"decoder",
        [NSNumber numberWithLong:dataId],   @"dataId",
        [NSNumber numberWithBool:NO],       @"variable",
        [NSNumber numberWithLong:5],       @"length",
        nil];
    [dataDictionary setObject:aDictionary forKey:@"Current"];
    
    return dataDictionary;
}


#pragma mark •••Bit Processing Protocol
- (void) processIsStarting
{
    readOnce = NO;
}

- (void) processIsStopping
{
}

//note that everything called by these routines MUST be threadsafe
- (void) startProcessCycle
{
    if(!readOnce){
        @try { 
            if(shipValues){
                [self shipAllValues]; 
            }
        }
		@catch(NSException* localException) { 
			//catch this here to prevent it from falling thru, but nothing to do.
        }
    }
}

- (void) endProcessCycle
{
	readOnce = NO;
}

- (BOOL) processValue:(int)channel
{
	if(channel==0)return temperature!=0;
	else return humidity!=0;
}

- (void) setProcessOutput:(int)channel value:(int)value
{
    //nothing to do
}

- (NSString*) processingTitle
{
    return [NSString stringWithFormat:@"%@",[self identifier]];
}

- (double) convertedValue:(int)channel
{
	if(channel==0)return temperature;
	else return humidity;
}

- (double) maxValueForChan:(int)channel
{
	if(channel==0)	return 100;
	else			return 100;
}

- (double) minValueForChan:(int)channel
{
	return 0;
}

- (void) getAlarmRangeLow:(double*)theLowLimit high:(double*)theHighLimit channel:(int)channel
{
	@synchronized(self){
		if(channel==0){
			*theLowLimit  = lowLimit0;
			*theHighLimit = highLimit0;
		}
		else {
			*theLowLimit  = lowLimit1;
			*theHighLimit = highLimit1;
		}
	}		
}

- (NSString*) identifier
{
    return [NSString stringWithFormat:@"CC4189 %u",[self uniqueIdNumber]];
}

- (void) postCouchDBRecord
{
    if((lastTimePosted-timeMeasured) > 10){
        lastTimePosted = timeMeasured;
        NSDictionary* values = [NSDictionary dictionaryWithObjectsAndKeys:
                                [NSNumber numberWithFloat:    temperature], @"temperature",
                                [NSNumber numberWithFloat:    humidity],    @"humidity",                                [NSNumber numberWithInt:   10],    @"humidity",
                                nil];
        [[NSNotificationCenter defaultCenter] postNotificationName:@"ORCouchDBAddObjectRecord" object:self userInfo:values];
    }
}

@end
