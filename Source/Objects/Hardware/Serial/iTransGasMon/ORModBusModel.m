//--------------------------------------------------------
// ORModBusModel
// Created by Mark  A. Howe on Tues Sept 8, 2009
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2009 University of North Carolina. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORModBusModel.h"
#import "ORSerialPort.h"
#import "ORSerialPortList.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORTimeRate.h"
#import "ORiTransGasSensorModel.h"

#pragma mark •••External Strings
NSString* ORModBusModelPollTimeChanged		= @"ORModBusModelPollTimeChanged";
NSString* ORModBusModelSerialPortChanged	= @"ORModBusModelSerialPortChanged";
NSString* ORModBusModelPortNameChanged		= @"ORModBusModelPortNameChanged";
NSString* ORModBusModelPortStateChanged		= @"ORModBusModelPortStateChanged";
NSString* ORModBusModelSensorsChanged		= @"ORModBusModelSensorsChanged";
NSString* ORModBusModelSensorAdded			= @"ORModBusModelSensorAdded";
NSString* ORModBusModelSensorRemoved		= @"ORModBusModelSensorRemoved";
NSString* ORModBusModelTimeout				= @"ORModBusModelTimeout";
NSString* ORModBusModelShipValues			= @"ORModBusModelShipValues";

NSString* ORModBusLock						= @"ORModBusLock";


@interface ORModBusModel (private)
- (void) processResponse:(NSData*)theData;
- (void) doPoll;
- (void) timeout;
- (void) processOneCommandFromQueue;
- (void) sendData:(NSData*)theCommand;
@end

@implementation ORModBusModel
- (id) init
{
	self = [super init];
    [self registerNotificationObservers];
	return self;
}

- (void) dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];
    [buffer release];
    [portName release];
    if([serialPort isOpen]){
        [serialPort close];
    }
	[lastRequest release];
	[cmdQueue release];
	[serialPort setDelegate:nil];
	[serialPort release];
	[timeRates release];

	
	[super dealloc];
}

- (void) sleep
{
	[super sleep];
}

- (void) wakeUp
{
	[super wakeUp];

}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"ModBus.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORModBusController"];
}

- (NSString*) helpURL
{
	//return @"RS232/ModBus.html";
	return nil;
}

- (void) registerNotificationObservers
{
	NSNotificationCenter* notifyCenter = [NSNotificationCenter defaultCenter];
	
    [notifyCenter addObserver : self
                     selector : @selector(dataReceived:)
                         name : ORSerialPortDataReceived
                       object : nil];
	
    [notifyCenter addObserver : self
                     selector : @selector(removeSensorByNote:)
                         name : ORiTransRemoveGasSensor
                       object : nil];	
}

- (void) dataReceived:(NSNotification*)note
{
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		NSData* theData = [[note userInfo] objectForKey:@"data"];
		[self processResponse:theData];
 	}
}


#pragma mark •••Accessors

- (ORTimeRate*)timeRate
{
	return timeRates;
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelPollTimeChanged object:self];
	
	if(pollTime){
		[self performSelector:@selector(doPoll) withObject:nil afterDelay:.1];
	}
	else {
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(doPoll) object:nil];
	}
}

- (void) pollSensors
{
	ORiTransGasSensorModel* aSensor;
	for(aSensor in sensors){
		[aSensor readValues:self];
		if(shipValues){
			[aSensor shipDataRecords];
		}
	}
}

- (uint32_t) timeMeasured
{
	return timeMeasured;
}

- (NSMutableArray*) sensors
{
	return sensors;
}

- (void) setSensors:(NSMutableArray*)someSensors
{
	[[[self undoManager] prepareWithInvocationTarget:self] setSensors:sensors];
	
	[someSensors retain];
	[sensors release];
	sensors = someSensors;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelSensorsChanged object:self];
}


- (BOOL) portWasOpen
{
    return portWasOpen;
}

- (void) setPortWasOpen:(BOOL)aPortWasOpen
{
    portWasOpen = aPortWasOpen;
}

- (NSString*) portName
{
    return portName;
}

- (void) setPortName:(NSString*)aPortName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPortName:portName];
    
    if(![aPortName isEqualToString:portName]){
        [portName autorelease];
        portName = [aPortName copy];    
		
        BOOL valid = NO;
        NSEnumerator *enumerator = [ORSerialPortList portEnumerator];
        ORSerialPort *aPort;
        while (aPort = [enumerator nextObject]) {
            if([portName isEqualToString:[aPort name]]){
                [self setSerialPort:aPort];
                if(portWasOpen){
                    [self openPort:YES];
				}
                valid = YES;
                break;
            }
        } 
        if(!valid){
            [self setSerialPort:nil];
        }       
    }
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelPortNameChanged object:self];
}

- (ORSerialPort*) serialPort
{
    return serialPort;
}

- (void) setSerialPort:(ORSerialPort*)aSerialPort
{
    [aSerialPort retain];
    [serialPort release];
    serialPort = aSerialPort;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelSerialPortChanged object:self];
}

- (void) serialPortWriteProgress:(NSDictionary *)dataDictionary;
{
}

- (void) openPort:(BOOL)state
{
    if(state) {
        [serialPort open];
		[serialPort setSpeed:9600];
		[serialPort setParityNone];
		[serialPort setStopBits2:NO];
		[serialPort setDataBits:8];
		[serialPort commitChanges];
		[serialPort setDelegate:self];
		for(id aSensor in sensors)[(ORiTransGasSensorModel*)aSensor setFullRead:YES];
    }
    else [serialPort close];
	
    portWasOpen = [serialPort isOpen];
		
    [[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelPortStateChanged object:self];
}

- (void) insertSensor:(id)aSensor atIndex:(int)anIndex
{
	if(!sensors)[self setSensors:[NSMutableArray array]];
    [[[self undoManager] prepareWithInvocationTarget:self] removeSensor:aSensor];
	[sensors insertObject:aSensor atIndex:anIndex];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelSensorAdded object:self];
}

- (void) addSensor:(id)aSensor
{
	if(!sensors)[self setSensors:[NSMutableArray array]];
	[self insertSensor:aSensor atIndex:0];
}

- (void) removeSensorByNote:(NSNotification*)aNote
{
	id aSensor = [aNote object];
	if([sensors containsObject: aSensor]){
		[[aSensor retain] autorelease];
		[self removeSensor:aSensor];
	}
}

- (void) removeSensor:(id)aSensor
{
	int index = (int)[sensors indexOfObject:aSensor];
	[[[self undoManager] prepareWithInvocationTarget:self] insertSensor:aSensor atIndex:index];
	[sensors removeObject:aSensor];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelSensorRemoved object:self];
}

- (id) sensor:(int)i
{
	if(i<[sensors count])return [sensors objectAtIndex:i];
	else return nil;
}

#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setPollTime:[decoder decodeIntForKey:@"ORModBusModelPollTime"]];
	[self setShipValues:[decoder decodeBoolForKey:@"shipValues"]];
	[self setPortWasOpen:[decoder decodeBoolForKey:@"ORModBusModelPortWasOpen"]];
    [self setPortName:[decoder decodeObjectForKey: @"portName"]];
 	[self setSensors:[decoder decodeObjectForKey:@"sensors"]];
	
	timeRates = [[ORTimeRate alloc] init];

    [self registerNotificationObservers];
	[[self undoManager] enableUndoRegistration];

	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeInteger:pollTime forKey:@"ORModBusModelPollTime"];
    [encoder encodeBool:shipValues forKey:@"shipValues"];
    [encoder encodeBool:portWasOpen forKey:@"ORModBusModelPortWasOpen"];
    [encoder encodeObject:portName forKey: @"portName"];
    [encoder encodeObject:sensors forKey: @"sensors"];
}

- (NSData*) lastRequest
{
	return lastRequest;
}

- (void) setLastRequest:(NSData*)aRequest
{
	[aRequest retain];
	[lastRequest release];
	lastRequest = aRequest;    
}
#pragma mark ••• Commands
- (unsigned int) crc:(unsigned char*) mess count:(int)cnt
{
	int shift; 
	int i; 
	unsigned short crc=0xffff; 
	for (i=0; i<cnt; i++) { 
		crc = crc^mess[i]; 
		for (shift=1; shift<=8; shift++) { 
			unsigned char lastbit = crc & 0x0001; 
			crc = crc >> 1; 
			if (lastbit==1) crc = crc^0xA001 ; 
		} 
	} 
	return crc;
}

- (void) readHoldingReg:(int)reg_num deviceAddress:(int) address
{
	NSMutableData* theData = [NSMutableData dataWithLength:8];
	unsigned char* mess = (unsigned char*)[theData bytes];
	
	reg_num = reg_num - 40001;
	mess[0] = address;
	mess[1] = 0x03;				//holding reg read function
	mess[2] = reg_num >> 8;	
	mess[3] = reg_num & 0x00ff;
	mess[4] = 0x00;				//num Regs hi
	mess[5] = 0x01;				//num Regs lo
	
	unsigned int crc = [self crc:mess count:6];
	mess[6] = crc & 0x00FF;
	mess[7] = (crc>>8)&0xff;
	
	[self sendData:theData];
}

- (void) writeHoldingReg:(int)reg_num deviceAddress:(int) address withValue:(int)aValue
{
	NSMutableData* theData = [NSMutableData dataWithLength:8];
	unsigned char* mess = (unsigned char*)[theData bytes];
	reg_num = reg_num - 40001;
	
	mess[0] = address;
	mess[1] = 0x10; //holding reg write function
	mess[2] = reg_num >> 8;
	mess[3] = reg_num & 0x00FF;
	mess[4] = 0x00;
	mess[5] = 0x01;
	mess[6] = 0x02;
	mess[7] = aValue >>8;
	mess[8] = aValue & 0x00FF;
	
	unsigned int temp = [self crc:mess count:9];
	
	unsigned char crc_hi = temp >> 8 ;
	unsigned char crc_lo = temp & 0x00FF;
	
	mess[9] = crc_hi;
	mess[10] = crc_lo;
	[self sendData:theData];
}

- (BOOL) shipValues
{
    return shipValues;
}

- (void) setShipValues:(BOOL)aShipState
{
    [[[self undoManager] prepareWithInvocationTarget:self] setShipValues:shipValues];
    shipValues = aShipState;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelShipValues object:self];
}
@end

@implementation ORModBusModel (private)

- (void) sendData:(NSData*)theCommand
{	
	if(!cmdQueue)cmdQueue = [[NSMutableArray array] retain];
	[cmdQueue addObject:theCommand];
	if(!lastRequest)[self processOneCommandFromQueue];
}

- (void) timeout
{	
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
	NSLogError(@"command timeout",@"ModBus",nil);
    [[NSNotificationCenter defaultCenter] postNotificationName:ORModBusModelTimeout object:self];
	[self setLastRequest:nil];
	[cmdQueue removeAllObjects];
	[self processOneCommandFromQueue];	 //do the next command in the queue
	lastAddress  = 0;
	lastRegister = 0;
	response     = NO;
}

- (void) processOneCommandFromQueue
{
	if([cmdQueue count] == 0) return;
	NSData* cmdData = [[[cmdQueue objectAtIndex:0] retain] autorelease];
	[cmdQueue removeObjectAtIndex:0];
	
	[self setLastRequest:cmdData];
	[serialPort writeDataInBackground:cmdData];
	[self performSelector:@selector(timeout) withObject:nil afterDelay:1];
	
}

- (void) processResponse:(NSData*)theData
{
	//these sensors response by echoing the orginal data packet followed by the true response
	//so we have to jump thru hoops to decode it all
	unsigned char* bytes = (unsigned char*)[theData bytes];
	BOOL done = NO;
	if(!response){
		//this is the echo of the command, all we need is the function
		//should probably check to see is the command is a error or not
		response = YES;
		lastAddress = bytes[0];
		lastRegister = (bytes[2]<<8 | bytes[3]) + 1;
		done = NO;
	}
	else {
		if((lastAddress == bytes[0]) && (bytes[2]==2)){
			//check the crc
			int len = (int)[theData length];
			unsigned short theReceivedCRC = bytes[len-1]<<8 | bytes[len-2];
			unsigned short actualCRC      = [self crc:bytes count:len-2];
			if(theReceivedCRC == actualCRC){
				ORiTransGasSensorModel* aSensor;
				for(aSensor in sensors){
					if([aSensor baseAddress] == bytes[0]){
						unsigned short theValue = (bytes[3]<<8) | bytes[4];
						[aSensor processRegister:40000+lastRegister value:theValue];
					}
				}
			}	
			done = YES;
		}
	}
	
	if(done){
		lastAddress  = 0;
		lastRegister = 0;
		response     = NO;
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(timeout) object:nil];
		[self setLastRequest:nil];			 //clear the last request
		[self processOneCommandFromQueue];	 //do the next command in the queue
	}
}

- (void) doPoll
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(doPoll) object:nil];
	[self pollSensors];
	[self performSelector:@selector(doPoll) withObject:nil afterDelay:pollTime];
}



@end
